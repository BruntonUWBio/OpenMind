FUNCTION  <SNR>102_OnCursorMovedNormalMode()
Called 1 time
Total time:   0.000139
 Self time:   0.000101

count  total (s)   self (s)
    1   0.000041   0.000003   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1              0.000096   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 5 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    5              0.000025   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  <SNR>137_CreateCountDict()
Called 20 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
   20              0.000082     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  <SNR>97_has_fresh_changes()
Called 2 times
Total time:   0.000032
 Self time:   0.000013

count  total (s)   self (s)
    2   0.000031   0.000012   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  airline#util#exec_funcrefs()
Called 7 times
Total time:   0.003525
 Self time:   0.000331

count  total (s)   self (s)
   33              0.000037     for Fn in a:list
   33   0.003381   0.000187       let code = call(Fn, a:000)
   33              0.000033       if code != 0
    7              0.000007         return code
                                  endif
   26              0.000020     endfor
                                return 0

FUNCTION  AutoPairsSpace()
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000009   let line = getline('.')
    2              0.000009   let prev_char = line[col('.')-2]
    2              0.000002   let cmd = ''
    2              0.000006   let cur_char =line[col('.')-1]
    2              0.000009   if has_key(g:AutoPairsParens, prev_char) && g:AutoPairsParens[prev_char] == cur_char
                                let cmd = "\<SPACE>".s:Left
                              endif
    2              0.000006   return "\<SPACE>".cmd

FUNCTION  <SNR>98_obsolete_gitgutter_signs_to_remove()
Called 2 times
Total time:   0.000287
 Self time:   0.000268

count  total (s)   self (s)
    2              0.000003   let signs_to_remove = []  " list of [<id (number)>, ...]
    2              0.000003   let remove_all_signs = 1
    2   0.000028   0.000009   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
   26              0.000029   for line_number in keys(old_gitgutter_signs)
   24              0.000072     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
   24              0.000029       let remove_all_signs = 0
   24              0.000017     endif
   24              0.000012   endfor
    2              0.000006   let s:remove_all_old_signs = remove_all_signs
    2              0.000002   return signs_to_remove

FUNCTION  ale#linter#Get()
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000002     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    1              0.000004     for l:original_filetype in split(a:original_filetypes, '\.')
                                    let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
                                    let l:linter_names = s:GetLinterNames(l:original_filetype)
                                    let l:all_linters = ale#linter#GetAll(l:filetype)
                                    let l:filetype_linters = []
                            
                                    if type(l:linter_names) == type('') && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
                                    call extend(l:possibly_duplicated_linters, l:filetype_linters)
                                endfor
                            
    1              0.000001     let l:name_list = []
    1              0.000001     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
    1              0.000003     for l:linter in reverse(l:possibly_duplicated_linters)
                                    if index(l:name_list, l:linter.name) < 0
                                        call add(l:name_list, l:linter.name)
                                        call add(l:combined_linters, l:linter)
                                    endif
                                endfor
                            
    1              0.000002     return reverse(l:combined_linters)

FUNCTION  <SNR>52_dir()
Called 4 times
Total time:   0.000146
 Self time:   0.000035

count  total (s)   self (s)
    4   0.000145   0.000034   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>89_Get()
Called 1008 times
Total time:   0.004799
 Self time:   0.004799

count  total (s)   self (s)
 1008              0.002013   let res=get(a:dict, a:key, '')
 1008              0.000932   if res is ''
  594              0.000432     return ''
                              else
  414              0.000548     return a:prefix. res
                              endif

FUNCTION  <SNR>102_InsideCommentOrString()
Called 14 times
Total time:   0.002222
 Self time:   0.002222

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
   14              0.002056   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
   14              0.000035   if stridx(syntax_group, 'Comment') > -1
                                return 1
                              endif
                            
   14              0.000028   if stridx(syntax_group, 'String') > -1
                                return 2
                              endif
                            
   14              0.000011   return 0

FUNCTION  <SNR>98_find_current_signs()
Called 10 times
Total time:   0.009991
 Self time:   0.009607

count  total (s)   self (s)
   10              0.000018   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
   10              0.000011   let other_signs = []      " [<line_number (number),...]
   10              0.000016   let dummy_sign_placed = 0
                            
   10              0.000022   redir => signs
   10              0.000287     silent execute "sign place buffer=" . a:bufnr
   10              0.000023   redir END
                            
  250              0.000582   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
  240              0.002319     let components  = split(sign_line)
  240              0.000841     let name        = split(components[2], '=')[1]
  240              0.000543     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
  240              0.000892       let line_number = str2nr(split(components[0], '=')[1])
  240              0.000474       if name =~# 'GitGutter'
   48              0.000172         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
   48              0.000096         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
   48              0.000146         let gitgutter_signs[line_number] = {'id': id, 'name': name}
   48              0.000023       else
  192              0.000357         call add(other_signs, line_number)
  192              0.000105       endif
  240              0.000121     end
  240              0.000128   endfor
                            
   10   0.000186   0.000056   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
   10   0.000167   0.000035   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
   10   0.000165   0.000043   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  <SNR>52_abs_path()
Called 10 times
Total time:   0.000162
 Self time:   0.000162

count  total (s)   self (s)
   10              0.000136   let p = resolve(expand('#'.a:bufnr.':p'))
   10              0.000023   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  airline#statusline()
Called 107 times
Total time:   0.001024
 Self time:   0.001024

count  total (s)   self (s)
  107              0.000437   if has_key(s:contexts, a:winnr)
  107              0.000508     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>98_next_sign_id()
Called 25 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   25              0.000035   let next_id = s:next_sign_id
   25              0.000038   let s:next_sign_id += 1
   25              0.000024   return next_id

FUNCTION  <SNR>52_windows()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000016   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#check_mode()
Called 107 times
Total time:   0.105219
 Self time:   0.006517

count  total (s)   self (s)
  107              0.000277   let context = s:contexts[a:winnr]
                            
  107              0.000417   if get(w:, 'airline_active', 1)
   44              0.000097     let l:m = mode()
   44              0.000052     if l:m ==# "i"
   40              0.000070       let l:mode = ['insert']
   40              0.000040     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
    4              0.000005       let l:mode = ['normal']
    4              0.000002     endif
   44              0.000157     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   44              0.000027   else
   63              0.000095     let l:mode = ['inactive']
   63              0.000189     let w:airline_current_mode = get(g:airline_mode_map, '__')
   63              0.000041   endif
                            
  107              0.000230   if g:airline_detect_modified && &modified
   49              0.000136     call add(l:mode, 'modified')
   49              0.000031   endif
                            
  107              0.000141   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  107              0.000337   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  107              0.000177   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  107              0.000130   if &readonly || ! &modifiable
   34              0.000086     call add(l:mode, 'readonly')
   34              0.000019   endif
                            
  107              0.000314   let mode_string = join(l:mode)
  107              0.000280   if get(w:, 'airline_lastmode', '') != mode_string
    4   0.001060   0.000026     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    4   0.097704   0.000036     call airline#highlighter#highlight(l:mode, context.bufnr)
    4              0.000010     let w:airline_lastmode = mode_string
    4              0.000002   endif
                            
  107              0.000090   return ''

FUNCTION  gitgutter#hunk#reset()
Called 8 times
Total time:   0.000263
 Self time:   0.000055

count  total (s)   self (s)
    8   0.000114   0.000029   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
    8   0.000147   0.000024   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>52_exists_file()
Called 2 times
Total time:   0.000089
 Self time:   0.000029

count  total (s)   self (s)
    2   0.000089   0.000029   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  airline#util#append()
Called 238 times
Total time:   0.001887
 Self time:   0.001887

count  total (s)   self (s)
  238              0.000422   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  238              0.000529   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  238              0.000546   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#vimtex#apply()
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000004   if exists("b:vimtex")
                                let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x)
                                let w:airline_section_x.=s:spc.g:airline_left_alt_sep.s:spc.'%{airline#extensions#vimtex#get_scope()}'
                              endif

FUNCTION  <SNR>56_SetupDebugMode()
Called 8 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    8              0.000013         if !s:debug_mode_already_setup
                                        if s:GetIniSetting('settings', 'debug') == 'true'
                                            let s:is_debug_on = s:true
                                        else
                                            let s:is_debug_on = s:false
                                        endif
                                        let s:debug_mode_already_setup = s:true
                                    endif

FUNCTION  <SNR>93_get_accented_line()
Called 34 times
Total time:   0.001076
 Self time:   0.001076

count  total (s)   self (s)
   34              0.000040   if a:self._context.active
   16              0.000020     let contents = []
   16              0.000078     let content_parts = split(a:contents, '__accent')
   34              0.000035     for cpart in content_parts
   18              0.000112       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   18              0.000038       call add(contents, cpart)
   18              0.000010     endfor
   16              0.000047     let line = join(contents, a:group)
   16              0.000071     let line = substitute(line, '__restore__', a:group, 'g')
   16              0.000008   else
   18              0.000179     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   18              0.000073     let line = substitute(line, '%#__restore__#', '', 'g')
   18              0.000009   endif
   34              0.000033   return line

FUNCTION  <SNR>52_vimdiff()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    4              0.000012     for winid in win_findbuf(a:bufnr)
    2              0.000007       if getwinvar(winid, '&diff')
                                    return 1
                                  endif
    2              0.000002     endfor
    2              0.000001     return 0

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 34 times
Total time:   0.000349
 Self time:   0.000349

count  total (s)   self (s)
   34              0.000096   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  airline#themes#get_highlight()
Called 198 times
Total time:   0.017731
 Self time:   0.000825

count  total (s)   self (s)
  198   0.017692   0.000786   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>56_SetLastHeartbeatInMemory()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005         let s:last_heartbeat = {'last_activity_at': a:last_activity_at, 'last_heartbeat_at': a:last_heartbeat_at, 'file': a:file}

FUNCTION  ale#highlight#RemoveHighlights()
Called 8 times
Total time:   0.001867
 Self time:   0.001867

count  total (s)   self (s)
  272              0.000390     for l:match in getmatches()
  264              0.000641         if l:match.group =~# '^ALE'
  264              0.000436             call matchdelete(l:match.id)
  264              0.000131         endif
  264              0.000162     endfor

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 73 times
Total time:   0.001470
 Self time:   0.001470

count  total (s)   self (s)
   73              0.000179   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  let buffer = fugitive#buffer()
                                  if buffer.type('blob')
                                    let b:fugitive_name = buffer.repo().translate(buffer.path())
                                  endif
                                catch
                                endtry
                              endif
                            
   73              0.000125   if empty(b:fugitive_name)
   73              0.000434     return fnamemodify(bufname('%'), s:fmod)
                              else
                                return fnamemodify(b:fugitive_name, s:fmod)
                              endif

FUNCTION  gitgutter#sign#update_signs()
Called 2 times
Total time:   0.012364
 Self time:   0.000154

count  total (s)   self (s)
    2   0.003544   0.000016   call s:find_current_signs(a:bufnr)
                            
    2              0.000038   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    2   0.000311   0.000024   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    2              0.000005   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    2              0.000002   if flicker_possible
    1   0.000041   0.000010     call s:add_dummy_sign(a:bufnr)
    1              0.000001   endif
                            
    2   0.000053   0.000017   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    2   0.008312   0.000021   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    2              0.000003   if flicker_possible
    1   0.000041   0.000004     call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
    1              0.000001   endif

FUNCTION  ale#statusline#Count()
Called 88 times
Total time:   0.001781
 Self time:   0.000515

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
   88   0.001716   0.000450     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>98_add_dummy_sign()
Called 1 time
Total time:   0.000031
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000010   0.000003   if !gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
    1              0.000006     execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
    1   0.000013   0.000004     call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 1)
    1              0.000001   endif

FUNCTION  <SNR>93_section_is_empty()
Called 41 times
Total time:   0.000270
 Self time:   0.000270

count  total (s)   self (s)
   41              0.000046   let start=1
                            
                              " do not check for inactive windows or the tabline
   41              0.000049   if a:self._context.active == 0
   23              0.000018     return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   18              0.000032   if get(g:, 'airline_skip_empty_sections', 0) == 0
   18              0.000013     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>14_SaveRestoreOptions()
Called 30 times
Total time:   0.004711
 Self time:   0.001712

count  total (s)   self (s)
   30              0.000030     if a:save
   15   0.003056   0.000057         return s:SaveOptions(a:list)
                                else
  120              0.000175         for [key, value] in items(a:dict)
  105              0.000188             if key !~ '@'
   90              0.000598                 call setbufvar('', '&'. key, value)
   90              0.000052             else
   15              0.000070                 call call('setreg', [key[1]] + value)
   15              0.000010             endif
  105              0.000084             unlet value
  105              0.000065         endfor
   15              0.000009     endif

FUNCTION  <SNR>133_is_modified_and_added()
Called 5 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    5              0.000010   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  airline#extensions#default#apply()
Called 7 times
Total time:   0.002482
 Self time:   0.000255

count  total (s)   self (s)
    7              0.000012   let winnr = a:context.winnr
    7              0.000011   let active = a:context.active
                            
    7   0.000049   0.000032   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    4   0.000740   0.000027     call s:build_sections(a:builder, a:context, s:layout[0])
    4              0.000003   else
    3   0.000097   0.000012     let text = s:get_section(winnr, 'c')
    3              0.000003     if empty(text)
                                  let text = ' %f%m '
                                endif
    3   0.000024   0.000014     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    3              0.000001   endif
                            
    7   0.000242   0.000035   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    7   0.000041   0.000017   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    5   0.001197   0.000026     call s:build_sections(a:builder, a:context, s:layout[1])
    5              0.000002   endif
                            
    7              0.000006   return 1

FUNCTION  <SNR>93_get_transitioned_seperator()
Called 27 times
Total time:   0.010117
 Self time:   0.000731

count  total (s)   self (s)
   27              0.000027   let line = ''
   27   0.004825   0.000118   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   27              0.000086   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
   27   0.004790   0.000111     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   27              0.000070     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   27              0.000065     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   27              0.000049     let line .= '%#'.a:group.'#'
   27              0.000013   endif
   27              0.000026   return line

FUNCTION  ale#highlight#UpdateHighlights()
Called 8 times
Total time:   0.011133
 Self time:   0.008072

count  total (s)   self (s)
    8              0.000045     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    8   0.001893   0.000026     call ale#highlight#RemoveHighlights()
                            
  272              0.000234     for l:item in l:item_list
  264              0.000328         if l:item.type is# 'W'
  148              0.000255             if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
  148              0.000160                 let l:group = 'ALEWarning'
  148              0.000078             endif
  148              0.000132         elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
   36              0.000040             let l:group = 'ALEStyleError'
   36              0.000026         else
   80              0.000089             let l:group = 'ALEError'
   80              0.000033         endif
                            
  264              0.000316         let l:line = l:item.lnum
  264              0.000303         let l:col = l:item.col
  264              0.000531         let l:end_line = get(l:item, 'end_lnum', l:line)
  264              0.000519         let l:end_col = get(l:item, 'end_col', l:col)
                            
                                    " Set all of the positions, which are chunked into Lists which
                                    " are as large as will be accepted by matchaddpos.
  264   0.003469   0.002275         call map(   ale#highlight#CreatePositions(l:line, l:col, l:end_line, l:end_col),   'matchaddpos(l:group, v:val)')
  264              0.000211     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    8              0.000012     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call matchaddpos(l:group, [l:item.lnum])
                                        endif
                                    endfor
                                endif

FUNCTION  <SNR>102_PollFileParseResponse()
Called 1 time
Total time:   0.000386
 Self time:   0.000283

count  total (s)   self (s)
    1   0.000118   0.000015   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    1              0.000253   exec s:python_command "ycm_state.HandleFileParseRequest()"

FUNCTION  airline#parts#filetype()
Called 83 times
Total time:   0.000780
 Self time:   0.000780

count  total (s)   self (s)
   83              0.000750   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â€¦' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 2 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000008   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  <SNR>133_process_modified_and_added()
Called 2 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    2              0.000003   let offset = 0
    4              0.000006   while offset < a:from_count
    2              0.000004     let line_number = a:to_line + offset
    2              0.000004     call add(a:modifications, [line_number, 'modified'])
    2              0.000002     let offset += 1
    2              0.000002   endwhile
    4              0.000005   while offset < a:to_count
    2              0.000003     let line_number = a:to_line + offset
    2              0.000004     call add(a:modifications, [line_number, 'added'])
    2              0.000002     let offset += 1
    2              0.000001   endwhile

FUNCTION  airline#parts#iminsert()
Called 34 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
   34              0.000064   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   34              0.000022   return ''

FUNCTION  <SNR>98_highlight_name_for_change()
Called 49 times
Total time:   0.000372
 Self time:   0.000372

count  total (s)   self (s)
   49              0.000058   if a:text ==# 'added'
    4              0.000004     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
   42              0.000041     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
    3              0.000003     return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  airline#extensions#term#apply()
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000002   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_c', spc.'%f')
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  <SNR>14_PrintColorStatistics()
Called 15 times
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
   15              0.000031     if get(g:, 'colorizer_debug', 0)
                                    echohl Title
                                    echom printf("Colorstatistics at: %s", strftime("%H:%M"))
                                    echom printf("Duration: %s", reltimestr(s:relstop))
                                    for name in sort(keys(extend(s:color_patterns, s:color_patterns_special)))
                                        let value = get(extend(s:color_patterns, s:color_patterns_special), name)
                                        echom printf("%15s: %ss", name, (value[-1] == [] ? '  0.000000' : reltimestr(value[-1])))
                                    endfor
                                    echohl Normal
                                endif

FUNCTION  <SNR>133_process_modified()
Called 3 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    3              0.000003   let offset = 0
   25              0.000031   while offset < a:to_count
   22              0.000039     let line_number = a:to_line + offset
   22              0.000048     call add(a:modifications, [line_number, 'modified'])
   22              0.000021     let offset += 1
   22              0.000016   endwhile

FUNCTION  gitgutter#process_buffer()
Called 10 times
Total time:   0.046062
 Self time:   0.000362

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   10   0.000389   0.000042   if gitgutter#utility#is_active(a:bufnr)
    2   0.000047   0.000015     if a:force || s:has_fresh_changes(a:bufnr)
                            
    2              0.000002       let diff = ''
    2              0.000002       try
    2   0.002889   0.000051         let diff = gitgutter#diff#run_diff(a:bufnr, 0)
    2              0.000006       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    2              0.000003       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
    2              0.000001     endif
    2              0.000001   else
    8   0.042510   0.000027     call s:clear(a:bufnr)
    8              0.000004   endif

FUNCTION  <SNR>52_unc_path()
Called 2 times
Total time:   0.000037
 Self time:   0.000010

count  total (s)   self (s)
    2   0.000037   0.000010   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>50_repo_head_ref()
Called 34 times
Total time:   0.001296
 Self time:   0.000981

count  total (s)   self (s)
   34   0.000693   0.000498   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
   34   0.000527   0.000407   return readfile(self.dir('HEAD'))[0]

FUNCTION  268()
Called 7 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    7              0.000018   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>102_OnTextChangedInsertMode()
Called 14 times
Total time:   0.023927
 Self time:   0.004374

count  total (s)   self (s)
   14   0.000629   0.000054   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   14              0.000014   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
   14   0.004905   0.000064   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
   14              0.000043   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
   14   0.008093   0.000166   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
    8   0.000161   0.000034     call s:Complete()
    8   0.006106   0.000023     call s:InvokeCompletion()
    8              0.000008   endif
                            
   14              0.003695   exec s:python_command "ycm_state.OnCursorMoved()"
                            
   14              0.000035   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  <SNR>110_syn_stack()
Called 1 time
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
    1              0.000003     if !exists('*synstack')
                                    return []
                                endif
    1              0.000158     return map(synstack(line('.'), col('.') - 1), "synIDattr(v:val, 'name')")

FUNCTION  <SNR>133_write_buffer()
Called 2 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
    2              0.000055   let bufcontents = getbufline(a:bufnr, 1, '$')
    2              0.000006   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
    2              0.000226   call writefile(bufcontents, a:file)

FUNCTION  ale#ShouldDoNothing()
Called 3 times
Total time:   0.000321
 Self time:   0.000155

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
    3              0.000010     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files
    3              0.000016     if index(g:ale_filetype_blacklist, getbufvar(a:buffer, '&filetype')) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode
    3              0.000008     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
    3              0.000010     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    3              0.000003     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox
    3   0.000042   0.000012     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if ALE is disabled.
    3   0.000074   0.000013     if !ale#Var(a:buffer, 'enabled')
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
    3   0.000086   0.000011     if ale#FileTooLarge()
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
    3              0.000019     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
    3              0.000001     return 0

FUNCTION  airline#extensions#ale#get_error()
Called 44 times
Total time:   0.006228
 Self time:   0.000148

count  total (s)   self (s)
   44   0.006221   0.000141   return airline#extensions#ale#get('error')

FUNCTION  Colorizer#AutoCmds()
Called 15 times
Total time:   0.003901
 Self time:   0.003901

count  total (s)   self (s)
   15              0.000037     if a:enable && !get(g:, 'colorizer_debug', 0)
   15              0.000034         aug Colorizer
   15              0.003410             au!
   15              0.000124             au InsertLeave *  sil call Colorizer#ColorLine('!', line('w0'), line('w$'))
   15              0.000064             au TextChangedI * sil call Colorizer#ColorLine('', line('.'),line('.'))
   15              0.000081             au GUIEnter,ColorScheme * sil call Colorizer#DoColor('!', 1, line('$'))
   15              0.000069             au WinEnter,BufWinEnter * sil call Colorizer#ColorWinEnter()
   15              0.000014         aug END
   15              0.000004     else
                                    aug Colorizer
                                        au!
                                    aug END
                                    aug! Colorizer
                                endif

FUNCTION  <SNR>102_PollCompletion()
Called 16 times
Total time:   0.005541
 Self time:   0.000367

count  total (s)   self (s)
   16   0.003543   0.000094   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
    8              0.000072     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
    8              0.000005     return
                              endif
                            
    8   0.001620   0.000047   let response = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
    8              0.000046   let s:completion = {   'start_column': response.completion_start_column,   'candidates': response.completions }
    8   0.000186   0.000034   call s:Complete()

FUNCTION  airline#extensions#po#apply()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000008   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                              endif

FUNCTION  <SNR>102_Complete()
Called 16 times
Total time:   0.000279
 Self time:   0.000211

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
   16              0.000069   if s:completion.start_column > col( '.' ) || empty( s:completion.candidates )
   16   0.000123   0.000055     call s:CloseCompletionMenu()
   16              0.000009   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects the
                                " first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim to
                                " deselect the first candidate and in turn preserve the user's current text
                                " until he explicitly chooses to replace it with a completion.
                                call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
                              endif

FUNCTION  jedi#show_call_signatures()
Called 2 times
Total time:   0.030695
 Self time:   0.030532

count  total (s)   self (s)
    2              0.000005     if s:_init_python == 0
                                    return 1
                                endif
    2              0.000012     let [line, col] = [line('.'), col('.')]
    2              0.000022     let curline = getline(line)
    2              0.000002     let reload_signatures = 1
                            
                                " Caching.  On the same line only.
    2              0.000007     if line == s:show_call_signatures_last[0]
                                    " Check if the number of commas and parenthesis before or after the
                                    " cursor has not changed since the last call, which means that the
                                    " argument position was not changed and we can skip repainting.
                                    let prevcol = s:show_call_signatures_last[1]
                                    let prevline = s:show_call_signatures_last[2]
                                    if substitute(curline[:col-2], '[^,()]', '', 'g') == substitute(prevline[:prevcol-2], '[^,()]', '', 'g') && substitute(curline[(col-2):], '[^,()]', '', 'g') == substitute(prevline[(prevcol-2):], '[^,()]', '', 'g')
                                        let reload_signatures = 0
                                    endif
                                endif
    2              0.000016     let s:show_call_signatures_last = [line, col, curline]
                            
    2              0.000002     if reload_signatures
    2   0.030586   0.030423         PythonJedi jedi_vim.show_call_signatures()
    2              0.000002     endif

FUNCTION  gitgutter#utility#cd_cmd()
Called 2 times
Total time:   0.000139
 Self time:   0.000026

count  total (s)   self (s)
    2   0.000070   0.000017   let cd = s:unc_path(a:bufnr) ? 'pushd' : (s:windows() ? 'cd /d' : 'cd')
    2   0.000069   0.000009   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>96_LintOnEnter()
Called 8 times
Total time:   0.000241
 Self time:   0.000079

count  total (s)   self (s)
    8   0.000206   0.000044     if ale#Var(a:buffer, 'enabled')&& g:ale_lint_on_enter&& has_key(b:, 'ale_file_changed')
                                    call remove(b:, 'ale_file_changed')
                                    call ale#Queue(0, 'lint_file', a:buffer)
                                endif

FUNCTION  Colorizer#LocalFTAutoCmds()
Called 2 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
    2              0.000002     if a:enable
    1              0.000001         aug FTColorizer
    1              0.000046             au!
    1              0.000004             au InsertLeave <buffer> silent call Colorizer#ColorLine('', line('w0'), line('w$'))
    1              0.000003             au CursorMoved,CursorMovedI <buffer> call Colorizer#ColorLine('',line('.'), line('.'))
    1              0.000003             au WinEnter,BufWinEnter <buffer> silent call Colorizer#ColorWinEnter()
                                        "au BufLeave <buffer> call Colorizer#ColorOff()
    1              0.000003             au GUIEnter,ColorScheme <buffer> silent call Colorizer#DoColor('!', 1, line('$'))
    1              0.000002             if get(g:, 'colorizer_cursormoved', 0)
                                            au CursorMoved,CursorMovedI * call Colorizer#ColorLine('', line('.'),line('.'))
                                            au CusorHold, CursorHoldI * silent call Colorizer#ColorLine('!', line('w0'), line('w$'))
                                        endif
    1              0.000001         aug END
    1              0.000002         if !exists("b:undo_ftplugin")
                                        " simply unlet a dummy variable
                                        let b:undo_ftplugin = 'unlet! b:Colorizer_foobar'
                                    endif
                                    " Delete specific auto commands, because the filetype
                                    " has been changed.
    1              0.000002         let b:undo_ftplugin .= '| exe "sil! au! FTColorizer"'
    1              0.000002         let b:undo_ftplugin .= '| exe "sil! aug! FTColorizer"'
    1              0.000002         let b:undo_ftplugin .= '| exe ":ColorClear"'
    1              0.000000     else
    1              0.000002         aug FTColorizer
    1              0.000042             au!
    1              0.000001         aug END
    1              0.000024         aug! FTColorizer
    1              0.000000     endif

FUNCTION  <SNR>14_Reltime()
Called 266 times
Total time:   0.000858
 Self time:   0.000858

count  total (s)   self (s)
  266              0.000786     return exists("a:1") ? reltime(a:1) : reltime()

FUNCTION  <SNR>102_VisitedBufferRequiresReparse()
Called 8 times
Total time:   0.000102
 Self time:   0.000050

count  total (s)   self (s)
    8              0.000025   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
    4              0.000003     return 0
                              endif
                            
    4   0.000065   0.000013   return s:AllowedToCompleteInCurrentBuffer()

FUNCTION  nerdtree#checkForBrowse()
Called 8 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    8              0.000024     if !isdirectory(a:dir)
    8              0.000003         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>56_HandleActivity()
Called 25 times
Total time:   0.001923
 Self time:   0.001051

count  total (s)   self (s)
   25   0.000419   0.000103         let file = s:GetCurrentFile()
   25              0.000211         if !empty(file) && file !~ "-MiniBufExplorer-" && file !~ "--NO NAME--" && file !~ "^term:"
   21   0.000460   0.000079             let last = s:GetLastHeartbeat()
   21              0.000032             let now = localtime()
                            
                                        " Create a heartbeat when saving a file, when the current file
                                        " changes, and when still editing the same file but enough time
                                        " has passed since the last heartbeat.
   21   0.000272   0.000112             if a:is_write || s:EnoughTimePassed(now, last) || file != last.file
                                            call s:AppendHeartbeat(file, now, a:is_write, last)
                                        else
   21              0.000050                 if now - s:last_heartbeat.last_activity_at > s:local_cache_expire
    1   0.000017   0.000011                     call s:SetLastHeartbeatInMemory(now, last.last_heartbeat_at, last.file)
    1              0.000001                 endif
   21              0.000008             endif
                            
                                        " When buffering heartbeats disabled, no need to re-check the
                                        " heartbeats buffer.
   21              0.000029             if s:buffering_heartbeats_enabled
                            
                                            " Only send buffered heartbeats every s:send_buffer_seconds
   21              0.000046                 if now - s:last_sent > s:send_buffer_seconds
    1   0.000018   0.000009                     call s:SendHeartbeats()
    1              0.000001                 endif
   21              0.000013             endif
   21              0.000007         endif

FUNCTION  <SNR>94_add_section()
Called 31 times
Total time:   0.001531
 Self time:   0.000622

count  total (s)   self (s)
   31              0.000099     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   31   0.000216   0.000109     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
   31              0.000023     if condition
                                  call a:builder.add_raw('%(')
                                endif
   31   0.000983   0.000181     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   31              0.000024     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  <SNR>47_on_window_changed()
Called 9 times
Total time:   0.008103
 Self time:   0.000180

count  total (s)   self (s)
    9              0.000031   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
    5              0.000003     return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    4              0.000049   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
    4              0.000054   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    3              0.000002     return
                              endif
    1              0.000003   let g:airline_last_window_changed = l:key
    1   0.000009   0.000007   call s:init()
    1   0.007927   0.000006   call airline#update_statusline()

FUNCTION  <SNR>93_get_seperator()
Called 22 times
Total time:   0.012674
 Self time:   0.000189

count  total (s)   self (s)
   22   0.004154   0.000078   if s:should_change_group(a:prev_group, a:group)
   22   0.008515   0.000106     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#highlighter#get_highlight()
Called 669 times
Total time:   0.057381
 Self time:   0.024417

count  total (s)   self (s)
  669              0.001878   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
  669   0.017207   0.002456     let fg = s:get_syn(a:group, 'fg')
  669   0.016083   0.002058     let bg = s:get_syn(a:group, 'bg')
  669              0.005885     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  669              0.002314     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  669              0.000757     let opts = a:000
  669              0.000554     if bold
  106              0.000126       let opts = ['bold']
  106              0.000058     endif
  669   0.007294   0.003106     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
  669              0.000369   endif
  669              0.001681   let s:hl_groups[a:group] = res
  669              0.000587   return res

FUNCTION  Colorizer#ColorOff()
Called 1 time
Total time:   0.000533
 Self time:   0.000074

count  total (s)   self (s)
    1   0.000379   0.000006     for _match in s:GetMatchList()
                                    sil! call matchdelete(_match.id)
                                endfor
    1   0.000097   0.000011     call Colorizer#LocalFTAutoCmds(0)
    1              0.000003     if exists("s:conceal")
    1              0.000016       let [&l:cole, &l:cocu] = s:conceal
    1              0.000003       if !empty(hlID('ColorTermESC'))
    1              0.000025           syn clear ColorTermESC
    1              0.000000       endif
    1              0.000001     endif
    1              0.000004     unlet! b:Colorizer_did_syntax w:match_list s:conceal

FUNCTION  gitgutter#diff#process_hunks()
Called 2 times
Total time:   0.001660
 Self time:   0.000090

count  total (s)   self (s)
    2              0.000002   let modified_lines = []
   12              0.000013   for hunk in a:hunks
   10   0.001626   0.000056     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   10              0.000007   endfor
    2              0.000002   return modified_lines

FUNCTION  <SNR>102_InvokeCompletion()
Called 8 times
Total time:   0.006083
 Self time:   0.003134

count  total (s)   self (s)
    8              0.003068   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
    8   0.003004   0.000055   call s:PollCompletion()

FUNCTION  <SNR>81_airline_ale_count()
Called 88 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
   88              0.000183   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  airline#util#shorten()
Called 68 times
Total time:   0.000934
 Self time:   0.000934

count  total (s)   self (s)
   68              0.000332   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â€¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'â€¦'
                                endif
                              else
   68              0.000069     return a:text
                              endif

FUNCTION  <SNR>106_FindItemAtCursor()
Called 2 times
Total time:   0.000424
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000003     let l:buf = bufnr('')
    2              0.000007     let l:info = get(g:ale_buffer_info, l:buf, {})
    2              0.000007     let l:loclist = get(l:info, 'loclist', [])
    2              0.000005     let l:pos = getcurpos()
    2   0.000391   0.000017     let l:index = ale#util#BinarySearch(l:loclist, l:buf, l:pos[1], l:pos[2])
    2              0.000004     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    2              0.000003     return [l:info, l:loc]

FUNCTION  <SNR>99_reset_summary()
Called 10 times
Total time:   0.000165
 Self time:   0.000048

count  total (s)   self (s)
   10   0.000162   0.000045   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>14_HasGui()
Called 15 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
   15              0.000142     return has("gui_running") || (exists("+tgc") && &tgc)

FUNCTION  ale#FileTooLarge()
Called 3 times
Total time:   0.000075
 Self time:   0.000022

count  total (s)   self (s)
    3   0.000067   0.000014     let l:max = ale#Var(bufnr(''), 'maximum_file_size')
                            
    3              0.000007     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>89_exec_separator()
Called 129 times
Total time:   0.037278
 Self time:   0.002768

count  total (s)   self (s)
  129              0.000198   if pumvisible()
   30              0.000018     return
                              endif
   99   0.009329   0.000375   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   99   0.009124   0.000347   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   99              0.000229   let group = a:from.'_to_'.a:to.a:suffix
   99              0.000091   if a:inverse
   29              0.000116     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   29              0.000018   else
   70              0.000275     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   70              0.000040   endif
   99              0.000254   let a:dict[group] = colors
   99   0.017142   0.000363   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>21_record()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000002 	if s:locked | retu | en
    1              0.000002 	let bufnr = a:bufnr + 0
    1              0.000002 	let bufname = bufname(bufnr)
    1              0.000002 	if bufnr > 0 && !empty(bufname)
                            		cal filter(s:mrbs, 'v:val != bufnr')
                            		cal insert(s:mrbs, bufnr)
                            		cal s:addtomrufs(bufname)
                            	en

FUNCTION  <SNR>133_is_removed()
Called 8 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    8              0.000015   return a:from_count > 0 && a:to_count == 0

FUNCTION  ale#pattern_options#SetOptions()
Called 8 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    8              0.000026     if !g:ale_pattern_options_enabled || empty(g:ale_pattern_options)
    8              0.000007         return
                                endif
                            
                                " The items will only be sorted whenever the patterns change.
                                if g:ale_pattern_options != s:last_pattern_options
                                    let s:last_pattern_options = deepcopy(g:ale_pattern_options)
                                    " The patterns are sorted, so they are applied consistently.
                                    let s:sorted_items = sort(   items(g:ale_pattern_options),   function('s:CmpPatterns'))
                                endif
                            
                                let l:filename = expand('#' . a:buffer . ':p')
                            
                                for [l:pattern, l:options] in s:sorted_items
                                    if match(l:filename, l:pattern) >= 0
                                        for [l:key, l:value] in items(l:options)
                                            call setbufvar(a:buffer, l:key, l:value)
                                        endfor
                                    endif
                                endfor

FUNCTION  ale#Var()
Called 15 times
Total time:   0.000294
 Self time:   0.000294

count  total (s)   self (s)
   15              0.000042     let l:nr = str2nr(a:buffer)
   15              0.000031     let l:full_name = 'ale_' . a:variable_name
                            
   15              0.000031     if bufexists(l:nr)
   15              0.000034         let l:vars = getbufvar(l:nr, '')
   15              0.000023     elseif has_key(g:, 'ale_fix_buffer_data')
                                    let l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
                                else
                                    let l:vars = {}
                                endif
                            
   15              0.000045     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>14_GetColorPattern()
Called 15 times
Total time:   0.000721
 Self time:   0.000721

count  total (s)   self (s)
                                "let list = map(copy(a:list), ' ''\%(-\@<!\<'' . v:val . ''\>-\@!\)'' ')
                                "let list = map(copy(a:list), ' ''\%(-\@<!\<'' . v:val . ''\>-\@!\)'' ')
   15              0.000192     let list = copy(a:list)
                                " Force the old re engine. It should be faster without backtracking.
   15              0.000506     return '\%#=1\%(\<\('.join(copy(a:list), '\|').'\)\>\)'

FUNCTION  airline#extensions#ale#get()
Called 88 times
Total time:   0.013003
 Self time:   0.003060

count  total (s)   self (s)
   88              0.000247   if !exists(':ALELint')
                                return ''
                              endif
                            
   88              0.000147   let is_err = a:type ==# 'error'
   88              0.000171   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
   88              0.000119   let is_err = a:type ==# 'error'
   88   0.002132   0.000351   let counts = ale#statusline#Count(bufnr(''))
   88              0.000168   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
   88              0.000301   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
   88              0.000185     let errors = counts.error + counts.style_error
   88              0.000178     let num = is_err ? errors : counts.total - errors
   88              0.000051   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
   88   0.008779   0.000617   return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)

FUNCTION  <SNR>133_process_modified_and_removed()
Called 3 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
    3              0.000004   let offset = 0
   24              0.000025   while offset < a:to_count
   21              0.000034     let line_number = a:to_line + offset
   21              0.000046     call add(a:modifications, [line_number, 'modified'])
   21              0.000021     let offset += 1
   21              0.000012   endwhile
    3              0.000012   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  <SNR>72_is_excluded_window()
Called 7 times
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
    7              0.000012   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   28              0.000028   for matchw in g:airline_exclude_filenames
   21              0.000093     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   21              0.000013   endfor
                            
    7              0.000009   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    7              0.000004   return 0

FUNCTION  airline#util#wrap()
Called 414 times
Total time:   0.001919
 Self time:   0.001919

count  total (s)   self (s)
  414              0.000780   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  414              0.000409   return a:text

FUNCTION  gitgutter#debug#log()
Called 4 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
    4              0.000006   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>56_EnoughTimePassed()
Called 21 times
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
   21              0.000042         let prev = a:last.last_heartbeat_at
   21              0.000055         if a:now - prev > g:wakatime_HeartbeatFrequency * 60
                                        return s:true
                                    endif
   21              0.000021         return s:false

FUNCTION  <SNR>135_BlockEnd()
Called 3467 times
Total time:   0.144524
 Self time:   0.144524

count  total (s)   self (s)
                                " Note: Make sure to reset cursor position after using this function.
 3467              0.006308     call cursor(a:lnum, 0)
 3467              0.135867     return searchpos('\v^\s{,'.indent('.').'}\S', 'nW')[0] - 1

FUNCTION  <SNR>74_invoke_funcrefs()
Called 7 times
Total time:   0.022858
 Self time:   0.000215

count  total (s)   self (s)
    7   0.000139   0.000027   let builder = airline#builder#new(a:context)
    7   0.003574   0.000049   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    7              0.000007   if err == 1
    7   0.019039   0.000033     let a:context.line = builder.build()
    7              0.000039     let s:contexts[a:context.winnr] = a:context
    7              0.000049     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
    7              0.000003   endif

FUNCTION  <SNR>17_ALEQueueImpl()
Called 1 time
Total time:   0.000189
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000002     if a:linting_flag isnot# '' && a:linting_flag isnot# 'lint_file'
                                    throw "linting_flag must be either '' or 'lint_file'"
                                endif
                            
    1              0.000002     if type(a:buffer) != type(0)
                                    throw 'buffer_number must be a Number'
                                endif
                            
    1   0.000109   0.000007     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                " Remember that we want to check files for this buffer.
                                " We will remember this until we finally run the linters, via any event.
    1              0.000002     if a:linting_flag is# 'lint_file'
    1              0.000003         let s:should_lint_file_for_buffer[a:buffer] = 1
    1              0.000001     endif
                            
    1              0.000001     if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
                                endif
                            
    1   0.000053   0.000009     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    1              0.000001     if empty(l:linters)
                                    " If we have some previous buffer data, then stop any jobs currently
                                    " running and clear everything.
    1              0.000002         if has_key(g:ale_buffer_info, a:buffer)
                                        call ale#engine#RunLinters(a:buffer, [], 1)
                                    endif
                            
    1              0.000001         return
                                endif
                            
                                if a:delay > 0
                                    let s:queued_buffer_number = a:buffer
                                    let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
                                else
                                    call ale#Lint(-1, a:buffer)
                                endif

FUNCTION  <SNR>137_GetCounts()
Called 88 times
Total time:   0.001266
 Self time:   0.001165

count  total (s)   self (s)
   88              0.000351     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
   20   0.000173   0.000072         return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
   68              0.000183     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
   68              0.000134     return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>84_wordcount_update()
Called 17 times
Total time:   0.000693
 Self time:   0.000693

count  total (s)   self (s)
   17              0.000042   if empty(bufname(''))
                                return
                              endif
   17              0.000290   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  <SNR>54_Compile()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            
    2              0.000011     if !exists('b:livepreview_buf_data') || has_key(b:livepreview_buf_data, 'preview_running') == 0
    2              0.000001         return
                                endif
                            
                                " Change directory to handle properly sourced files with \input and bib
                                " TODO: get rid of lcd
                                execute 'lcd ' . b:livepreview_buf_data['root_dir']
                            
                                " Write the current buffer in a temporary file
                                silent exec 'write! ' . b:livepreview_buf_data['tmp_src_file']
                            
                                call s:RunInBackground(b:livepreview_buf_data['run_cmd'])
                            
                                lcd -

FUNCTION  jedi#complete_string()
Called 1 time
Total time:   0.000270
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000001     if a:autocomplete
    1   0.000219   0.000010         if !(g:jedi#popup_on_dot && jedi#do_popup_on_dot_in_highlight())
                                        return ''
                                    endif
                            
    1              0.000004         let s:saved_completeopt = &completeopt
    1              0.000010         set completeopt-=longest
    1              0.000002         set completeopt+=menuone
    1              0.000002         set completeopt-=menu
    1              0.000005         if &completeopt !~# 'noinsert\|noselect'
                                        " Patch 775 introduced noinsert and noselect, previously these
                                        " options didn't exist. Setting them in earlier versions results in
                                        " errors (E474).
    1              0.000005             if has('patch-7.4-775')
    1              0.000002                 if g:jedi#popup_select_first
    1              0.000003                     set completeopt+=noinsert
    1              0.000000                 else
                                                set completeopt+=noselect
                                            endif
    1              0.000000             else
                                            " To pass the tests we use this, it seems to get the closest to
                                            " the other options. I'm really not sure if this properly
                                            " works, but VIM 7.4-775 is already pretty old, so it might not
                                            " be a problem anymore in a few years.
                                            set completeopt+=longest
                                        endif
    1              0.000001         endif
    1              0.000001     elseif pumvisible()
                                    return "\<C-n>"
                                endif
    1              0.000006     return "\<C-x>\<C-o>\<C-r>=jedi#complete_opened(".a:autocomplete.")\<CR>"

FUNCTION  airline#util#getwinvar()
Called 59 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
   59              0.000155     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>56_InitAndHandleActivity()
Called 8 times
Total time:   0.000708
 Self time:   0.000082

count  total (s)   self (s)
    8   0.000097   0.000028         call s:SetupDebugMode()
    8   0.000161   0.000026         call s:SetupConfigFile()
    8   0.000447   0.000025         call s:HandleActivity(a:is_write)

FUNCTION  ale#CallWithCooldown()
Called 3 times
Total time:   0.001024
 Self time:   0.000092

count  total (s)   self (s)
    3   0.000042   0.000018     let l:now = ale#util#ClockMilliseconds()
                            
    3              0.000012     if l:now < get(s:timestamp_map, a:timestamp_key, -1)
                                    return 0
                                endif
                            
    3              0.000013     let s:timestamp_map[a:timestamp_key] = l:now + s:error_delay_ms
                            
    3   0.000935   0.000027     let l:return_value = call(a:func, a:arglist)
                            
    3              0.000008     let s:timestamp_map[a:timestamp_key] = -1
                            
    3              0.000003     return l:return_value

FUNCTION  <SNR>52_not_git_dir()
Called 2 times
Total time:   0.000110
 Self time:   0.000024

count  total (s)   self (s)
    2   0.000109   0.000023   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#hunk#hunks()
Called 2 times
Total time:   0.000025
 Self time:   0.000009

count  total (s)   self (s)
    2   0.000024   0.000008   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>102_AllowedToCompleteInBuffer()
Called 20 times
Total time:   0.000626
 Self time:   0.000557

count  total (s)   self (s)
   20              0.000075   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
   20              0.000090   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
    4              0.000004     return 0
                              endif
                            
   16   0.000127   0.000058   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
   16              0.000069   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
   16              0.000049   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
   16              0.000029   let allowed = whitelist_allows && blacklist_allows
   16              0.000016   if allowed
   16              0.000050     let s:previous_allowed_buffer_number = bufnr( a:buffer )
   16              0.000011   endif
   16              0.000016   return allowed

FUNCTION  AutoPairsInit()
Called 1 time
Total time:   0.000449
 Self time:   0.000299

count  total (s)   self (s)
    1              0.000002   let b:autopairs_loaded  = 1
    1              0.000002   if !exists('b:autopairs_enabled')
    1              0.000002     let b:autopairs_enabled = 1
    1              0.000000   end
    1              0.000001   let b:AutoPairsClosedPairs = {}
                            
    1              0.000002   if !exists('b:AutoPairs')
    1              0.000002     let b:AutoPairs = g:AutoPairs
    1              0.000000   end
                            
    1              0.000001   if !exists('b:AutoPairsMoveCharacter')
    1              0.000001     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    1              0.000001   end
                            
                              " buffer level map pairs keys
    7              0.000011   for [open, close] in items(b:AutoPairs)
    6   0.000120   0.000016     call AutoPairsMap(open)
    6              0.000007     if open != close
    3   0.000054   0.000008       call AutoPairsMap(close)
    3              0.000001     end
    6              0.000011     let b:AutoPairsClosedPairs[close] = open
    6              0.000003   endfor
                            
    9              0.000016   for key in split(b:AutoPairsMoveCharacter, '\s*')
    8              0.000022     let escaped_key = substitute(key, "'", "''", 'g')
    8              0.000072     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
    8              0.000005   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    1              0.000001   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    1              0.000006     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    1              0.000001   end
                            
    1              0.000001   if g:AutoPairsMapCh
    1              0.000007     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    1              0.000000   endif
                            
    1              0.000001   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    1              0.000001     let do_abbrev = ""
    1              0.000003     if v:version == 703 && has("patch489") || v:version > 703
    1              0.000001       let do_abbrev = "<C-]>"
    1              0.000001     endif
    1              0.000008     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutFastWrap != ''
    1              0.000008     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutBackInsert != ''
    1              0.000008     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    1              0.000008     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    1              0.000008     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    1              0.000001   end
                            
    1              0.000001   if g:AutoPairsShortcutJump != ''
    1              0.000008     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    1              0.000007     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    1              0.000001   end
                            

FUNCTION  <SNR>24_SetUpForNewFiletype()
Called 8 times
Total time:   0.000674
 Self time:   0.000510

count  total (s)   self (s)
    8              0.000019     let ft = a:filetype
                            
                                "for compound filetypes, if we don't know how to handle the full filetype
                                "then break it down and use the first part that we know how to handle
    8              0.000031     if ft =~ '\.' && !has_key(s:delimiterMap, ft)
                                    let filetypes = split(a:filetype, '\.')
                                    for i in filetypes
                                        if has_key(s:delimiterMap, i)
                                            let ft = i
                                            break
                                        endif
                                    endfor
                                endif
                            
    8              0.000011     let b:NERDSexyComMarker = ''
                            
    8              0.000020     if has_key(s:delimiterMap, ft)
    4              0.000010         let b:NERDCommenterDelims = s:delimiterMap[ft]
   20              0.000020         for i in ['left', 'leftAlt', 'right', 'rightAlt']
   16              0.000031             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = ''
                                        endif
   16              0.000009         endfor
   12              0.000012         for i in ['nested', 'nestedAlt']
    8              0.000015             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = 0
                                        endif
    8              0.000002         endfor
                                    " if g:NERD_<filetype>_alt_style is defined, use the alternate style
    4              0.000012         let b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")
    4              0.000014         if exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirstInit
                                        call s:SwitchToAlternativeDelimiters(0)
                                        let b:NERDCommenterFirstInit = 1
                                    endif
    4              0.000002     else
    4   0.000198   0.000034         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
    4              0.000003     endif
                            

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 8 times
Total time:   0.000243
 Self time:   0.000078

count  total (s)   self (s)
    8   0.000112   0.000025   let summary = gitgutter#hunk#summary(a:bufnr)
    8              0.000014   let summary[1] += a:count
    8   0.000110   0.000032   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>135_BlockStart()
Called 6934 times
Total time:   1.347159
 Self time:   1.347159

count  total (s)   self (s)
                                " Returns the definition statement line which encloses the current line.
                            
 6934              0.012466     let line = getline(a:lnum)
 6934              0.031424     if line !~ s:blank_regex
 5868              0.012359         let l:inferred_indent = indent(a:lnum)
 5868              0.003229     else
 1066              0.002307         let l:inferred_indent = prevnonblank(a:lnum)
 1066              0.000588     endif
                            
                                " Note: Make sure to reset cursor position after using this function.
 6934              0.012201     call cursor(a:lnum, 0)
                            
                                " In case the end of the block is indented to a higher level than the def
                                " statement plus one shiftwidth, we need to find the indent level at the
                                " bottom of that if/for/try/while/etc. block.
                                " Flags from searchpos() (same as search()):
                                " b: search Backward instead of forward
                                " n: do Not move the cursor
                                " W: don't Wrap around the end of the file
 6934              0.690944     let previous_definition = searchpos(s:def_regex, 'bnW')
                            
                                " Corner case of function being defined on the first line.
 6934              0.012837     if previous_definition[0] == 1
                                    " Just skip the while loop.
                                elseif previous_definition != [0, 0]
                                    " Lines that are blank have zero indent.
 7124              0.023919         while previous_definition != [0, 0] && indent(previous_definition[0]) >= l:inferred_indent
  190              0.005469             let previous_definition = searchpos(s:def_regex, 'bnW')
  190              0.000519             call cursor(previous_definition[0] - 1, 0)
  190              0.000184         endwhile
 6934              0.003520     endif
 6934              0.011705     let last_def = previous_definition[0]
 6934              0.005826     if last_def
 6870              0.011570         call cursor(last_def, 0)
 6870              0.012525         let last_def_indent = indent(last_def)
 6870              0.010575         call cursor(last_def, 0)
 6870              0.249076         let next_stmt_at_def_indent = searchpos('\v^\s{'.last_def_indent.'}[^[:space:]#]', 'nW')[0]
 6870              0.004281     else
   64              0.000098         let next_stmt_at_def_indent = -1
   64              0.000036     endif
                            
                                " Now find the class/def one shiftwidth lower than the start of the
                                " aforementioned indent block.
 6934              0.012869     if next_stmt_at_def_indent && (next_stmt_at_def_indent < a:lnum)
   64              0.000236         let max_indent = max([indent(next_stmt_at_def_indent) - &shiftwidth, 0])
   64              0.000040     else
 6870              0.027635         let max_indent = max([indent(prevnonblank(a:lnum)) - &shiftwidth, 0])
 6870              0.003864     endif
                            
 6934              0.058188     let result = searchpos('\v^\s{,'.max_indent.'}(def |class )\w', 'bcnW')[0]
                            
 6934              0.006965     return result
                            

FUNCTION  ale#Queue()
Called 1 time
Total time:   0.000246
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000001     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                " Default linting_flag to ''
    1              0.000003     let l:linting_flag = get(a:000, 0, '')
    1              0.000002     let l:buffer = get(a:000, 1, bufnr(''))
                            
    1   0.000236   0.000011     return ale#CallWithCooldown(   'dont_queue_until',   function('s:ALEQueueImpl'),   [a:delay, l:linting_flag, l:buffer],)

FUNCTION  gitgutter#sign#remove_dummy_sign()
Called 9 times
Total time:   0.000158
 Self time:   0.000079

count  total (s)   self (s)
    9   0.000102   0.000035   if gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
    1              0.000005     execute "sign unplace" s:dummy_sign_id "buffer=" . a:bufnr
    1   0.000016   0.000004     call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 0)
    1              0.000000   endif

FUNCTION  <SNR>89_CheckDefined()
Called 427 times
Total time:   0.010609
 Self time:   0.010609

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  427              0.001031   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  427              0.001092   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
 1257              0.001268   for val in a:colors
 1257              0.002079     if !empty(val) && val !=# 'NONE'
  427              0.000422       return a:colors
                                endif
  830              0.000512   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  ale#util#ClockMilliseconds()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000020     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  AutoPairsReturn()
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000002   if b:autopairs_enabled == 0
                                return ''
                              end
    1              0.000002   let line = getline('.')
    1              0.000003   let pline = getline(line('.')-1)
    1              0.000003   let prev_char = pline[strlen(pline)-1]
    1              0.000001   let cmd = ''
    1              0.000002   let cur_char = line[col('.')-1]
    1              0.000004   if has_key(b:AutoPairs, prev_char) && b:AutoPairs[prev_char] == cur_char
                                if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                  " Recenter before adding new line to avoid replacing line content
                                  let cmd = "zz"
                                end
                            
                                " If equalprg has been set, then avoid call =
                                " https://github.com/jiangmiao/auto-pairs/issues/24
                                if &equalprg != ''
                                  return "\<ESC>".cmd."O"
                                endif
                            
                                " conflict with javascript and coffee
                                " javascript   need   indent new line
                                " coffeescript forbid indent new line
                                if &filetype == 'coffeescript' || &filetype == 'coffee'
                                  return "\<ESC>".cmd."k==o"
                                else
                                  return "\<ESC>".cmd."=ko"
                                endif
                              end
    1              0.000001   return ''

FUNCTION  <SNR>102_InsideCommentOrStringAndShouldStop()
Called 14 times
Total time:   0.002445
 Self time:   0.000223

count  total (s)   self (s)
   14   0.002309   0.000087   let retval = s:InsideCommentOrString()
   14              0.000021   let inside_comment = retval == 1
   14              0.000022   let inside_string = retval == 2
                            
   14              0.000031   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
                              endif
                            
   14              0.000014   return retval

FUNCTION  <SNR>50_can_diffoff()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>47_init()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  <SNR>78_get_hunks()
Called 34 times
Total time:   0.001846
 Self time:   0.000725

count  total (s)   self (s)
   34              0.000126   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
   34   0.001297   0.000176   return {b:source_func}()

FUNCTION  <SNR>133_is_modified_and_removed()
Called 3 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    3              0.000008   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  <SNR>102_Pyeval()
Called 54 times
Total time:   0.012290
 Self time:   0.012290

count  total (s)   self (s)
   54              0.000075   if s:using_python3
   54              0.012168     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  gitgutter#utility#extension()
Called 2 times
Total time:   0.000037
 Self time:   0.000009

count  total (s)   self (s)
    2   0.000037   0.000009   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>131_build_command()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000002   if has('unix')
    2              0.000004     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  airline#highlighter#highlight()
Called 4 times
Total time:   0.097668
 Self time:   0.010754

count  total (s)   self (s)
    4              0.000009   let bufnr = a:0 ? a:1 : ''
    4              0.000009   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    4              0.000037   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    4              0.000009   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   12              0.000012   for mode in mapped
    8              0.000017     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
    8              0.000035     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    7              0.000019       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  115              0.000191       for kvp in items(dict)
  108              0.000194         let mode_colors = kvp[1]
  108              0.000176         let name = kvp[0]
  108              0.000222         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    2              0.000004           let name = 'airline_c'.bufnr
    2              0.000002         endif
  108   0.020286   0.000490         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  324              0.000408         for accent in keys(s:accents)
  216              0.000400           if !has_key(p.accents, accent)
                                        continue
                                      endif
  216              0.000503           let colors = copy(mode_colors)
  216              0.000443           if p.accents[accent][0] != ''
                                        let colors[0] = p.accents[accent][0]
                                      endif
  216              0.000359           if p.accents[accent][2] != ''
  108              0.000241             let colors[2] = p.accents[accent][2]
  108              0.000067           endif
  216              0.000287           if len(colors) >= 5
  216              0.000559             let colors[4] = get(p.accents[accent], 4, '')
  216              0.000116           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  216   0.039818   0.001054           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  216              0.000149         endfor
  108              0.000086       endfor
                            
                                  " TODO: optimize this
   82              0.000111       for sep in items(s:separators)
   75   0.028887   0.000533         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   75              0.000047       endfor
    7              0.000006     endif
    8              0.000006   endfor

FUNCTION  <SNR>133_is_added()
Called 10 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
   10              0.000016   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>14_ColorInit()
Called 15 times
Total time:   0.014316
 Self time:   0.004391

count  total (s)   self (s)
   15              0.000040     let s:force_hl = !empty(a:1)
   15              0.000089     let s:term_true_color = (exists('+tgc') && &tgc)
   15              0.000019     let s:stop = 0
                            
                                " default matchadd priority
   15              0.000025     let s:default_match_priority = -2
                            
                                " pattern/function dict
                                " Needed for s:ColorMatchingLines(), disabled, as this is too slow.
                                "let s:pat_func = {'#\x\{3,6\}': function('<sid>PreviewColorHex'),
                                "            \ 'rgba\=(\s*\%(\d\+%\?\D*\)\{3,4})':
                                "            \ function('<sid>ColorRGBValues'),
                                "            \ 'hsla\=(\s*\%(\d\+%\?\D*\)\{3,4})':
                                "            \ function('s:ColorHSLValues')}
                            
                                " Cache old values
   15              0.000032     if !exists("s:old_tCo")
                                    let s:old_tCo = &t_Co
                                endif
                            
   15              0.000027     if !exists("s:swap_fg_bg")
                                    let s:swap_fg_bg = 0
                                endif
                            
   15              0.000024     if !exists("s:round")
                                    let s:round = 0
                                endif
                            
                                " Enable Autocommands
   15              0.000030     if exists("g:colorizer_auto_color")
   15   0.003971   0.000070         call Colorizer#AutoCmds(g:colorizer_auto_color)
   15              0.000012     endif
                            
                                " Debugging
   15              0.000044     let s:debug = get(g:, 'colorizer_debug', 0)
                            
                                " Don't highlight comment?
   15              0.000040     let s:skip_comments = get(g:, 'colorizer_skip_comments', 0)
                            
                                " foreground / background contrast
   15              0.000058     let s:predefined_fgcolors = {}
   15              0.000047     let s:predefined_fgcolors['dark']  = ['444444', '222222', '000000']
   15              0.000034     let s:predefined_fgcolors['light'] = ['bbbbbb', 'dddddd', 'ffffff']
   15              0.000034     if !exists('g:colorizer_fgcontrast')
                                    " Default to black / white
                                    let g:colorizer_fgcontrast = len(s:predefined_fgcolors['dark']) - 1
                                elseif g:colorizer_fgcontrast >= len(s:predefined_fgcolors['dark'])
                                    call s:Warn("g:colorizer_fgcontrast value invalid, using default")
                                    let g:colorizer_fgcontrast = len(s:predefined_fgcolors['dark']) - 1
                                endif
                            
   15              0.000031     if !exists("s:old_fgcontrast")
                                    " if the value was changed since last time,
                                    " be sure to clear the old highlighting.
                                    let s:old_fgcontrast = g:colorizer_fgcontrast
                                endif
                            
   15              0.000034     if exists("g:colorizer_swap_fgbg")
                                    if s:swap_fg_bg != g:colorizer_swap_fgbg
                                        let s:force_hl = 1
                                    endif
                                    let s:swap_fg_bg = g:colorizer_swap_fgbg
                                endif
                            
   15              0.000023     if exists("g:colorizer_colornames")
                                    if exists("s:color_names") && s:color_names != g:colorizer_colornames
                                        let s:force_hl = 1
                                    endif
                                    let s:color_names = g:colorizer_colornames
                                else
   15              0.000018         let s:color_names = 1
   15              0.000011     endif
                            
   15              0.000041     let s:color_syntax = get(g:, 'colorizer_syntax', 0)
   15              0.000043     if get(g:, 'colorizer_only_unfolded', 0) && exists(":foldd") == 1
                                    let s:color_unfolded = 'foldd '
                                else
   15              0.000023         let s:color_unfolded = ''
   15              0.000007     endif
                            
   15              0.000029     if hlID('Color_Error') == 0
                                    hi default link Color_Error Error
                                endif
                            
   15              0.000035     if !s:force_hl && s:old_fgcontrast != g:colorizer_fgcontrast && s:swap_fg_bg == 0
                                    " Doesn't work with swapping fg bg colors
                                    let s:force_hl = 1
                                    let s:old_fgcontrast = g:colorizer_fgcontrast
                                endif
                            
                                " User manually changed the &t_Co option, so reset it
   15              0.000025     if s:old_tCo != &t_Co
                                    unlet! s:colortable
                                endif
                            
   15              0.000062     if !exists("s:init_css") || !exists("s:colortable") || empty(s:colortable)
                                    " Only calculate the colortable when running
                                    if &t_Co == 8
                                        let s:colortable = map(range(0,7), 's:Xterm2rgb16(v:val)')
                                    elseif &t_Co == 16
                                        let s:colortable = map(range(0,15), 's:Xterm2rgb16(v:val)')
                                    elseif &t_Co == 88
                                        let s:colortable = map(range(0,87), 's:Xterm2rgb88(v:val)')
                                    " terminal with 256 colors or gVim
                                    elseif &t_Co == 256 || empty(&t_Co)
                                        let s:colortable = map(range(0,255), 's:Xterm2rgb256(v:val)')
                                    endif
                                    if s:debug && exists("s:colortable")
                                        let g:colortable = s:colortable
                                    endif
                                    let s:init_css = 1
                                elseif s:force_hl
    1   0.000540   0.000007         call Colorizer#ColorOff()
    1              0.000000     endif
   15              0.000193     let s:conceal = [&l:cole, &l:cocu]
                            
   15              0.000066     let s:hex_pattern = get(g:, 'colorizer_hex_pattern', ['#', '\%(\x\{3}\|\x\{6}\|\x\{8\}\)', '\%(\>\|[-_]\)\@='])
                            
   15   0.000233   0.000084     if s:HasGui() || &t_Co >= 8 || s:HasColorPattern()
                                    " The list of available match() patterns
   15   0.004685   0.000064         let w:match_list = s:GetMatchList()
                                    " If the syntax highlighting got reset, force recreating it
   15              0.000088         if ((empty(w:match_list) || !hlexists(w:match_list[0].group) || (empty(<sid>SynID(w:match_list[0].group)) && !s:force_hl)))
   15              0.000023             let s:force_hl = 1
   15              0.000009         endif
   15              0.000029         if &t_Co > 16 || s:HasGui()
   15              0.000062             let s:colors = (exists("g:colorizer_x11_names") ? s:x11_color_names : s:w3c_color_names)
   15              0.000012         elseif &t_Co == 16
                                        " should work with 16 colors terminals
                                        let s:colors = s:xterm_16colors
                                    else
                                        let s:colors = s:xterm_8colors
                                    endif
   15              0.000028         if exists("g:colorizer_custom_colors")
                                        call extend(s:colors, g:colorizer_custom_colors, 'force')
                                    endif
   15   0.001127   0.000406         let s:colornamepattern =  s:GetColorPattern(keys(s:colors))
                                    "call map(w:match_list, 'v:val.pattern')
   15              0.000008     else
                                    throw "nocolor"
                                endif
                            
                                " Dictionary, containing all information on what to color
                                " Key: Name
                                " Value: List, containing 1) Pattern to find color
                                "                         2) func ref to call on the match of 1
                                "                         3) Name of variable, to enable or this enty
                                "                         4) condition, that must be fullfilled, before
                                "                            using this entry
                                "                       Â´ 5) reltime for dumping statistics
   15              0.000707     let s:color_patterns = { 'rgb': ['rgb(\s*\%(\d\+%\?[^)]*\)\{3})', function("s:ColorRGBValues"), 'colorizer_rgb', 1, [] ], 'rgba': ['rgba(\s*\%(\d\+%\?\D*\)\{3}\%(\%(0\?\%(.\d\+\)\?\)\|1\))', function("s:ColorRGBValues"), 'colorizer_rgba', 1, [] ], 'hsla': ['hsla\=(\s*\%(\d\+%\?\D*\)\{3}\%(\%(0\?\%(.\d\+\)\?\)\|1\)\=)', function("s:ColorHSLValues"), 'colorizer_hsla', 1, [] ], 'vimcolors':  ['\%(gui[fb]g\|cterm[fb]g\)\s*=\s*\<\%(\d\+\|#\x\{6}\|\w\+\)\>', function("s:PreviewVimColors"), 'colorizer_vimcolors', '&ft ==# "vim"', [] ], 'vimhighlight': ['^\s*\%(\%[Html]HiLink\s\+\w\+\s\+\w\+\)\|'. '\(^\s*hi\%[ghlight]!\?\s\+\(clear\)\@!\S\+.*\)', function("s:PreviewVimHighlight"), 'colorizer_vimhighlight', '&ft ==# "vim"', [] ], 'taskwarrior':  ['^color[^=]*=\zs.\+$', function("s:PreviewTaskWarriorColors"), 'colorizer_taskwarrior', 'expand("%:e") ==# "theme"', [] ], 'hex': [join(s:hex_pattern, ''), function("s:PreviewColorHex"), 'colorizer_hex', 1, [] ], 'vimhighl_dump': ['^\v\w+\s+xxx%((\s+(term|cterm%([bf]g)?|gui%(%([bf]g|sp))?'. ')\=[#0-9A-Za-z_,]+)+)?%(\_\s+links to \w+)?%( cleared)@!', function("s:PreviewVimHighlightDump"), 'colorizer_vimhighl_dump', 'empty(&ft)', [] ] }
                            
                                " term_conceal: patterns to hide, currently: [K$ and the color patterns [0m[01;32m
   15              0.000242     let s:color_patterns_special = { 'term': ['\%(\%x1b\[0m\)\?\(\%(\%x1b\[\d\+\%([:;]\d\+\)*m\)\+\)\([^\e]*\)\(\%x1b\%(\[0m\|\[K\)\)\=', function("s:PreviewColorTerm"), 'colorizer_term', [] ], 'term_nroff': ['\%(\(.\)\%u8\1\)\|\%(_\%u8.\)', function("s:PreviewColorNroff"), 'colorizer_nroff', [] ], 'term_conceal': [ ['\%(\(\%(\%x1b\[0m\)\?\%x1b\[\d\+\%([;:]\d\+\)*\a\)\|\%x1b\[K$\)', '\%d13', '\%(\%x1b\[K\)', '\%(\%x1b\]\d\+;\d\+;\)', '\%(\%x1b\\\)', '\%x1b(B\%x1b\[m', '\%x1b\[m\%x0f', '_\%u8.\@=', '\(.\)\%u8\%(\1\)\@='],  '', 'colorizer_term_conceal', [] ] }
                            
   15              0.000066     if exists("s:colornamepattern") && s:color_names
   15              0.000079         let s:color_patterns["colornames"] = [ s:colornamepattern, function("s:PreviewColorName"), 'colorizer_colornames', 1, [] ]
   15              0.000010     endif

FUNCTION  jedi#clear_call_signatures()
Called 1 time
Total time:   0.001134
 Self time:   0.001097

count  total (s)   self (s)
    1              0.000002     if s:_init_python == 0
                                    return 1
                                endif
                            
    1              0.000004     let s:show_call_signatures_last = [0, 0, '']
    1   0.001125   0.001088     PythonJedi jedi_vim.clear_call_signatures()

FUNCTION  airline#extensions#branch#head()
Called 34 times
Total time:   0.009478
 Self time:   0.000584

count  total (s)   self (s)
   34              0.000083   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
   34   0.006854   0.000107   call s:update_branch()
   34   0.002264   0.000117   call s:update_untracked()
                            
   34              0.000104   if exists('b:airline_head') && !empty(b:airline_head)
   34              0.000038     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let b:airline_head .= b:buffer_vcs_config[vcs].untracked
                              endfor
                            
                              if empty(heads)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  'â€¦' : '.')
                                endif
                              endif
                            
                              let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
                              let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
                              return b:airline_head

FUNCTION  airline#extensions#ctrlp#apply()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    2              0.000010   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  gitgutter#utility#shellescape()
Called 8 times
Total time:   0.000138
 Self time:   0.000127

count  total (s)   self (s)
    8              0.000094   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    6              0.000007     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    2              0.000004     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>133_process_added()
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000004   let offset = 0
    4              0.000004   while offset < a:to_count
    2              0.000004     let line_number = a:to_line + offset
    2              0.000006     call add(a:modifications, [line_number, 'added'])
    2              0.000003     let offset += 1
    2              0.000002   endwhile

FUNCTION  gitgutter#sign#clear_signs()
Called 8 times
Total time:   0.041848
 Self time:   0.000164

count  total (s)   self (s)
    8   0.006494   0.000031   call s:find_current_signs(a:bufnr)
                            
    8   0.000116   0.000058   let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
    8   0.035099   0.000034   call s:remove_signs(a:bufnr, sign_ids, 1)
    8   0.000128   0.000030   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})

FUNCTION  <SNR>98_upsert_new_gitgutter_signs()
Called 2 times
Total time:   0.008291
 Self time:   0.007790

count  total (s)   self (s)
    2   0.000022   0.000008   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    2   0.000019   0.000007   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
   51              0.000043   for line in a:modified_lines
   49              0.000082     let line_number = line[0]  " <number>
   49              0.000095     if index(other_signs, line_number) == -1  " don't clobber others' signs
   49   0.000552   0.000180       let name = s:highlight_name_for_change(line[1])
   49              0.000100       if !has_key(old_gitgutter_signs, line_number)  " insert
   25   0.000171   0.000068         let id = s:next_sign_id()
   25              0.006740         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
   25              0.000022       else  " update if sign has changed
   24              0.000046         let old_sign = old_gitgutter_signs[line_number]
   24              0.000027         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
   24              0.000010       endif
   49              0.000018     endif
   49              0.000038   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  Colorizer#ColorWinEnter()
Called 15 times
Total time:   0.000288
 Self time:   0.000288

count  total (s)   self (s)
   15              0.000029     let force = a:0 ? a:1 : 0
                                " be fast!
   15              0.000014     if !force
   14              0.000072         let ft_list = split(get(g:, "colorizer_auto_filetype", ""), ',')
   14              0.000114         if match(ft_list, "^".&ft."$") == -1
                                        " current filetype doesn't match g:colorizer_auto_filetype,
                                        " so nothing to do
   14              0.000011             return
                                    endif
                                    if get(b:, 'Colorizer_changedtick', 0) == b:changedtick && !empty(getmatches())
                                        " nothing to do
                                        return
                                    endif
                                endif
    1              0.000003     let g:colorizer_only_unfolded = 1
    1              0.000002     let _c = getpos('.')
    1              0.000001     if !exists("a:2")
                                    " don't call it recursively!
                                    call Colorizer#DoColor('', 1, line('$'))
                                endif
    1              0.000001     let b:Colorizer_changedtick = b:changedtick
    1              0.000002     unlet! g:colorizer_only_unfolded
    1              0.000002     call setpos('.', _c)

FUNCTION  gitgutter#async#available()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002   return s:available

FUNCTION  AutoPairsMap()
Called 9 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
                              " | is special key which separate map command from text
    9              0.000010   let key = a:key
    9              0.000008   if key == '|'
                                let key = '<BAR>'
                              end
    9              0.000029   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
    9              0.000078   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
                            

FUNCTION  <SNR>93_get_prev_group()
Called 41 times
Total time:   0.000362
 Self time:   0.000362

count  total (s)   self (s)
   41              0.000068   let x = a:i - 1
   46              0.000048   while x >= 0
   39              0.000078     let group = a:sections[x][0]
   39              0.000060     if group != '' && group != '|'
   34              0.000031       return group
                                endif
    5              0.000006     let x = x - 1
    5              0.000004   endwhile
    7              0.000005   return ''

FUNCTION  gitgutter#diff#parse_hunk()
Called 10 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
   10              0.000130   let matches = matchlist(a:line, s:hunk_re)
   10              0.000020   if len(matches) > 0
   10              0.000026     let from_line  = str2nr(matches[1])
   10              0.000030     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   10              0.000022     let to_line    = str2nr(matches[3])
   10              0.000025     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   10              0.000034     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>56_SetupConfigFile()
Called 8 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    8              0.000012         if !s:config_file_already_setup
                            
                                        " Create config file if does not exist
                                        if !filereadable(s:config_file)
                                            call writefile(s:default_configs, s:config_file)
                                        endif
                            
                                        " Make sure config file has api_key
                                        let found_api_key = s:false
                                        if s:GetIniSetting('settings', 'api_key') != '' || s:GetIniSetting('settings', 'apikey') != ''
                                            let found_api_key = s:true
                                        endif
                                        if !found_api_key
                                            call s:PromptForApiKey()
                                            echo "[WakaTime] Setup complete! Visit https://wakatime.com to view your coding activity."
                                        endif
                            
                                        let s:config_file_already_setup = s:true
                                    endif

FUNCTION  <SNR>131_on_exit_vim()
Called 2 times
Total time:   0.014880
 Self time:   0.000035

count  total (s)   self (s)
    2   0.014878   0.000033   call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))

FUNCTION  airline#parts#paste()
Called 34 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   34              0.000071   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>50_repo()
Called 68 times
Total time:   0.001292
 Self time:   0.001292

count  total (s)   self (s)
   68              0.000347   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
   68              0.000068   if dir !=# ''
   68              0.000135     if has_key(s:repos, dir)
   68              0.000138       let repo = get(s:repos, dir)
   68              0.000039     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
   68              0.000325     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  airline#update_statusline()
Called 2 times
Total time:   0.023081
 Self time:   0.000202

count  total (s)   self (s)
    2   0.000020   0.000013   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    7              0.000019   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
    5   0.000034   0.000020     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
    5              0.000013     call setwinvar(nr, 'airline_active', 0)
    5              0.000015     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    5   0.011254   0.000034     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    5              0.000003   endfor
                            
    2              0.000004   unlet! w:airline_render_left w:airline_render_right
    2              0.000023   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
    2              0.000004   let w:airline_active = 1
    2              0.000008   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    2   0.011653   0.000015   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>102_DisableOnLargeFile()
Called 16 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
   16              0.000036   if exists( 'b:ycm_largefile' )
   16              0.000022     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  ale#util#BinarySearch()
Called 2 times
Total time:   0.000374
 Self time:   0.000374

count  total (s)   self (s)
    2              0.000002     let l:min = 0
    2              0.000005     let l:max = len(a:loclist) - 1
                            
   14              0.000009     while 1
   14              0.000017         if l:max < l:min
    2              0.000002             return -1
                                    endif
                            
   12              0.000025         let l:mid = (l:min + l:max) / 2
   12              0.000026         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
   12              0.000019         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
    8              0.000013             let l:min = l:mid + 1
    8              0.000008         elseif l:item.lnum > a:line
    4              0.000005             let l:max = l:mid - 1
    4              0.000003         else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
   12              0.000006     endwhile

FUNCTION  <SNR>79_update_untracked()
Called 34 times
Total time:   0.002147
 Self time:   0.001798

count  total (s)   self (s)
   34              0.000227   let file = expand("%:p")
   34              0.000111   if empty(file) || isdirectory(file)
                                return
                              endif
                            
   34              0.000043   let needs_update = 1
  102              0.000127   for vcs in keys(s:vcs_config)
   68              0.000223     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
   68              0.000159     if has_key(s:vcs_config[vcs].untracked, file)
   34              0.000042       let needs_update = 0
   34   0.000487   0.000138       call airline#extensions#branch#update_untracked_config(file, vcs)
   34              0.000018     endif
   68              0.000073   endfor
                            
   34              0.000033   if !needs_update
   34              0.000021     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                let config = s:vcs_config[vcs]
                                if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
                                  call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
                              endfor

FUNCTION  airline#parts#readonly()
Called 97 times
Total time:   0.000526
 Self time:   0.000526

count  total (s)   self (s)
   97              0.000192   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
   97              0.000142     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>50_repo_dir()
Called 68 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
   68              0.000295   return join([self.git_dir]+a:000,'/')

FUNCTION  <SNR>102_OnInsertLeave()
Called 1 time
Total time:   0.002071
 Self time:   0.001316

count  total (s)   self (s)
    1   0.000050   0.000004   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1              0.000004   call timer_stop( s:pollers.completion.id )
    1              0.000002   let s:force_semantic = 0
    1              0.000004   let s:completion = s:default_completion
                            
    1   0.000719   0.000010   call s:OnFileReadyToParse()
    1              0.001275   exec s:python_command "ycm_state.OnInsertLeave()"
    1              0.000006   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  gitgutter#utility#setbufvar()
Called 85 times
Total time:   0.000996
 Self time:   0.000996

count  total (s)   self (s)
   85              0.000286   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   85              0.000156   let needs_setting = empty(dict)
   85              0.000226   let dict[a:varname] = a:val
   85              0.000088   if needs_setting
    1              0.000003     call setbufvar(a:buffer, 'gitgutter', dict)
    1              0.000001   endif

FUNCTION  <SNR>56_GetCurrentFile()
Called 25 times
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
   25              0.000300         return expand("%:p")

FUNCTION  airline#highlighter#exec()
Called 427 times
Total time:   0.076268
 Self time:   0.021599

count  total (s)   self (s)
  427              0.000578   if pumvisible()
                                return
                              endif
  427              0.000529   let colors = a:colors
  427              0.000449   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  427   0.038243   0.001482   let old_hi = airline#highlighter#get_highlight(a:group)
  427              0.000651   if len(colors) == 4
  101              0.000194     call add(colors, '')
  101              0.000050   endif
  427              0.000499   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  427              0.002209     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  427              0.000230   endif
  427   0.011999   0.001390   let colors = s:CheckDefined(colors)
  427   0.003856   0.001356   if old_hi != new_hi || !s:hl_group_exists(a:group)
  144   0.007261   0.002462     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
  144              0.000718     exe cmd
  144              0.000310     if has_key(s:hl_groups, a:group)
  144              0.000287       let s:hl_groups[a:group] = colors
  144              0.000078     endif
  144              0.000077   endif

FUNCTION  <SNR>78_get_hunks_gitgutter()
Called 34 times
Total time:   0.001121
 Self time:   0.000304

count  total (s)   self (s)
   34   0.000336   0.000149   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
   34   0.000718   0.000088   return GitGutterGetHunkSummary()

FUNCTION  <SNR>89_get_syn()
Called 1338 times
Total time:   0.028776
 Self time:   0.028776

count  total (s)   self (s)
 1338              0.002738   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 1338              0.001292   let color = ''
 1338              0.003237   if hlexists(a:group)
 1266              0.005585     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1266              0.000684   endif
 1338              0.002331   if empty(color) || color == -1
                                " should always exists
   72              0.000432     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   72              0.000122     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
   72              0.000030   endif
 1338              0.001204   return color

FUNCTION  <SNR>14_SaveOptions()
Called 15 times
Total time:   0.002999
 Self time:   0.002999

count  total (s)   self (s)
   15              0.000017     let save = {}
  120              0.000113     for item in a:list
  105              0.000215         if item !~ '^@'
   90              0.000609             exe "let save.". item. " = &l:". item
   90              0.000052         else
   15              0.000024             let save[item] = []
   15              0.000080             call add(save[item], getreg(item[1]))
   15              0.000050             call add(save[item], getregtype(item))
   15              0.000005         endif
  105              0.000159         if item == 'ma' && !&l:ma
                                        setl ma
                                    elseif item == 'ro' && &l:ro
                                        setl noro
                                    elseif item == 'lz' && &l:lz
                                        setl lz
                                    elseif item == 'ed' && &g:ed
                                        setl noed
                                    elseif item == 'gd' && &g:gd
                                        setl nogd
                                    endif
  105              0.000074     endfor
   15              0.000015     return save

FUNCTION  ale#events#EnterEvent()
Called 8 times
Total time:   0.000371
 Self time:   0.000130

count  total (s)   self (s)
                                " When entering a buffer, we are no longer quitting it.
    8              0.000029     call setbufvar(a:buffer, 'ale_quitting', 0)
    8              0.000026     let l:filetype = getbufvar(a:buffer, '&filetype')
    8              0.000029     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
    8   0.000277   0.000036     call s:LintOnEnter(a:buffer)

FUNCTION  <SNR>98_remove_signs()
Called 10 times
Total time:   0.035101
 Self time:   0.035011

count  total (s)   self (s)
   10   0.000107   0.000045   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
    4   0.000041   0.000013     let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
    4              0.000015     execute "sign unplace * buffer=" . a:bufnr
    4              0.000005     if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
    4              0.000003   else
   30              0.000038     for id in a:sign_ids
   24              0.034762       execute "sign unplace" id
   24              0.000041     endfor
    6              0.000004   endif

FUNCTION  <SNR>133_is_modified()
Called 8 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    8              0.000019   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  <SNR>97_clear()
Called 8 times
Total time:   0.042483
 Self time:   0.000136

count  total (s)   self (s)
    8   0.041880   0.000032   call gitgutter#sign#clear_signs(a:bufnr)
    8   0.000163   0.000042   call gitgutter#sign#remove_dummy_sign(a:bufnr, 1)
    8   0.000293   0.000030   call gitgutter#hunk#reset(a:bufnr)
    8   0.000140   0.000025   call s:reset_tick(a:bufnr)

FUNCTION  <SNR>133_process_hunk()
Called 10 times
Total time:   0.001570
 Self time:   0.000593

count  total (s)   self (s)
   10              0.000011   let modifications = []
   10              0.000019   let from_line  = a:hunk[0]
   10              0.000017   let from_count = a:hunk[1]
   10              0.000013   let to_line    = a:hunk[2]
   10              0.000017   let to_count   = a:hunk[3]
                            
   10   0.000056   0.000034   if s:is_added(from_count, to_count)
    2   0.000049   0.000015     call s:process_added(modifications, from_count, to_count, to_line)
    2   0.000083   0.000015     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    2              0.000004   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
    3   0.000196   0.000019     call s:process_modified(modifications, from_count, to_count, to_line)
    3   0.000103   0.000010     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    3              0.000006   elseif s:is_modified_and_added(from_count, to_count)
    2   0.000079   0.000021     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
    2   0.000072   0.000009     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
    2   0.000073   0.000012     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
    2              0.000004   elseif s:is_modified_and_removed(from_count, to_count)
    3   0.000188   0.000019     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
    3   0.000099   0.000010     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
    3   0.000103   0.000019     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
    3              0.000002   endif
   10              0.000011   return modifications

FUNCTION  airline#parts#mode()
Called 34 times
Total time:   0.000647
 Self time:   0.000198

count  total (s)   self (s)
   34   0.000632   0.000183   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  gitgutter#utility#getbufvar()
Called 96 times
Total time:   0.000740
 Self time:   0.000740

count  total (s)   self (s)
   96              0.000344   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   96              0.000185   if has_key(dict, a:varname)
   96              0.000150     return dict[a:varname]
                              else
                                if a:0
                                  return a:1
                                endif
                              endif

FUNCTION  gitgutter#utility#repo_path()
Called 6 times
Total time:   0.000113
 Self time:   0.000043

count  total (s)   self (s)
    6   0.000064   0.000021   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
    6   0.000045   0.000018   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>131_on_stdout_vim()
Called 10 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
   10              0.000027   call add(self.stdoutbuffer, a:data)

FUNCTION  ale#highlight#CreatePositions()
Called 264 times
Total time:   0.001194
 Self time:   0.001194

count  total (s)   self (s)
  264              0.000354     if a:line >= a:end_line
                                    " For single lines, just return the one position.
  264              0.000682         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  270()
Called 34 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
   34              0.000094   call add(self._sections, [a:group, a:contents])

FUNCTION  airline#parts#spell()
Called 34 times
Total time:   0.000675
 Self time:   0.000675

count  total (s)   self (s)
   34              0.000284   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   34              0.000056   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
   34              0.000025   return ''

FUNCTION  gitgutter#hunk#summary()
Called 49 times
Total time:   0.000658
 Self time:   0.000263

count  total (s)   self (s)
   49   0.000644   0.000249   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>72_sync_active_winnr()
Called 1 time
Total time:   0.015169
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000004   if exists('#airline') && winnr() != s:active_winnr
    1   0.015164   0.000004     call airline#update_statusline()
    1              0.000001   endif

FUNCTION  airline#extensions#whitespace#check()
Called 44 times
Total time:   0.003083
 Self time:   0.002598

count  total (s)   self (s)
   44              0.000121   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   44              0.000183   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
   10              0.000007     return ''
                              endif
                            
   34              0.000084   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                if index(checks, 'trailing') > -1
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
                              endif
   34   0.000617   0.000132   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  272()
Called 7 times
Total time:   0.019006
 Self time:   0.002916

count  total (s)   self (s)
    7              0.000007   let side = 1
    7              0.000006   let line = ''
    7              0.000007   let i = 0
    7              0.000012   let length = len(self._sections)
    7              0.000007   let split = 0
    7              0.000007   let is_empty = 0
    7              0.000007   let prev_group = ''
                            
   48              0.000053   while i < length
   41              0.000074     let section = self._sections[i]
   41              0.000062     let group = section[0]
   41              0.000066     let contents = section[1]
   41              0.000048     let pgroup = prev_group
   41   0.000514   0.000152     let prev_group = s:get_prev_group(self._sections, i)
   41              0.000078     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    2              0.000003       let group = 'airline_c'. self._context.bufnr
    2              0.000005     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    2              0.000004       let prev_group = 'airline_c'. self._context.bufnr
    2              0.000001     endif
   41              0.000032     if is_empty
                                  let prev_group = pgroup
                                endif
   41   0.000414   0.000144     let is_empty = s:section_is_empty(self, contents)
                            
   41              0.000032     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   41              0.000038     if group == ''
                                  let line .= contents
                                elseif group == '|'
    7              0.000007       let side = 0
    7              0.000012       let line .= contents
    7              0.000006       let split = 1
    7              0.000001     else
   34              0.000034       if prev_group == ''
    7              0.000013         let line .= '%#'.group.'#'
    7              0.000006       elseif split
    5              0.000004         if !is_empty
    5   0.001732   0.000024           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    5              0.000001         endif
    5              0.000004         let split = 0
    5              0.000004       else
   22              0.000018         if !is_empty
   22   0.012774   0.000100           let line .= s:get_seperator(self, prev_group, group, side)
   22              0.000010         endif
   22              0.000014       endif
   34   0.001258   0.000182       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   34              0.000017     endif
                            
   41              0.000065     let i = i + 1
   41              0.000037   endwhile
                            
    7              0.000009   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    5              0.000177     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    5              0.000005   endif
    7              0.000009   return line

FUNCTION  <SNR>89_hl_group_exists()
Called 283 times
Total time:   0.002500
 Self time:   0.002500

count  total (s)   self (s)
  283              0.000641   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  283              0.000211   return 1

FUNCTION  Colorizer#DoColor()
Called 15 times
Total time:   0.090153
 Self time:   0.009824

count  total (s)   self (s)
                                " initialize plugin
   15              0.000013     try
   15              0.000028         if v:version < 800 && !has('nvim')
                                        call s:Warn("Colorizer needs Vim 8.0")
                                        return
                                    endif
   15   0.014381   0.000065         call s:ColorInit(a:force)
   15              0.000035         if exists("a:1") && !empty(a:1)
                                        let s:color_syntax = ( a:1 =~# '^\%(syntax\|nomatch\)$' )
                                    endif
   15              0.000015     catch /nocolor/
                                    " nothing to do
                                    call s:Warn("Your terminal doesn't support colors or no colors". 'found in the current buffer!')
                                    return
                                endtry
   15              0.000016     let error = ""
                            
   15              0.000038     let _a   = winsaveview()
   15   0.003174   0.000093     let save = s:SaveRestoreOptions(1, {}, ['mod', 'ro', 'ma', 'lz', 'ed', 'gd', '@/'])
   15   0.000118   0.000063     let s:relstart = s:Reltime()
                            
                                " highlight Hex Codes:
                                "
                                " The :%s command is a lot faster than this:
                                ":g/#\x\{3,6}\>/call s:ColorMatchingLines(line('.'))
                                " Should color #FF0000
                                "              #F0F
                                "              #FFF
                                "
   15              0.000036     if &t_Co > 16 || s:HasGui()
                                " Also support something like
                                " CSS rgb(255,0,0)
                                "     rgba(255,0,0,1)
                                "     rgba(255,0,0,0.8)
                                "     rgba(255,0,0,0.2)
                                "     rgb(10%,0,100%)
                                "     hsl(0,100%,50%) -> hsl2rgb conversion RED
                                "     hsla(120,100%,50%,1) Lime
                                "     hsl(120,100%,25%) Darkgreen
                                "     hsl(120, 100%, 75%) lightgreen
                                "     hsl(120, 75%, 75%) pastelgreen
                                " highlight rgb(X,X,X) values
  150              0.000167         for Pat in values(s:color_patterns)
  135   0.000757   0.000332             let start = s:Reltime()
  135              0.000578             if !get(g:, Pat[2], 1) || (get(g:, Pat[2]. '_disable', 0) > 0)
                                            let Pat[4] = s:Reltime(start)
                                            " Coloring disabled
                                            continue
                                        endif
                            
                                        " 4th element in pattern is condition, that must be fullfilled,
                                        " before we continue
  135              0.000590             if !empty(Pat[3]) && !eval(Pat[3])
   60   0.000403   0.000206                 let Pat[4] = s:Reltime(start)
   60              0.000045                 continue
                                        endif
                            
                                        " Check, the pattern isn't too costly...
   75   0.032038   0.000341             if s:CheckTimeout(Pat[0], a:force) && !s:IsInComment()
    5              0.000030                 let cmd = printf(':sil keeppatterns %d,%d%ss/%s/\=call(Pat[1], [submatch(0)])/egin', a:line1, a:line2, s:color_unfolded, Pat[0])
    5              0.000002                 try
    5              0.000013                     if Pat[2] ==# 'colorizer_vimhighlight' && !empty(bufname(''))
                                                    " try to load the corresponding syntax file so the syntax
                                                    " groups will be defined
                                                    let s:extension = fnamemodify(expand('%'), ':t:r')
                                                    let s:old_syntax = exists("b:current_syntax") ? b:current_syntax : ''
                                                    call s:LoadSyntax(s:extension)
                                                endif
                            
    5              0.001243                     exe cmd
    5   0.000044   0.000023                     let Pat[4] = s:Reltime(start)
                            
    5              0.000005                     if s:stop
                                                    break
                                                endif
                            
    5              0.000005                 catch
                                                " some error occured, stop when finished (and don't setup auto
                                                " comands
                                                let error.=" Colorize: ". string(Pat)
                                                break
                            
                                            finally
    5              0.000007                     if exists("s:extension")
                                                    call s:LoadSyntax(&ft)
                                                    unlet! s:extension
                                                endif
    5              0.000001                 endtry
    5              0.000004             endif
   75              0.000049         endfor
   15              0.000010     else
                                    call s:Warn('Color configuration seems wrong, skipping colorization! Check t_Co setting!')
                                endif
                            
   45              0.000071     for Pat in [ s:color_patterns_special.term, s:color_patterns_special.term_nroff ]
   30   0.000180   0.000085         let start = s:Reltime()
   30   0.028422   0.000142         if (s:CheckTimeout(Pat[0], a:force)) && !s:IsInComment()
                            
    2              0.000009             if !get(g:, Pat[2], 1) || (get(s:, Pat[2]. '_disable', 0) > 0)
                                            " Coloring disabled
                                            continue
                                        endif
                            
    2              0.000004             if Pat[2] is# 'colorizer_nroff'
    1              0.000001               let arg = '[submatch(0)]'
    1              0.000001             else
    1              0.000002               let arg = '[submatch(1), submatch(2), submatch(3)]'
    1              0.000000             endif
    2              0.000011             let cmd = printf(':sil keeppatterns %d,%d%ss/%s/\=call(Pat[1],%s)/egin', a:line1, a:line2,  s:color_unfolded, Pat[0], arg)
    2              0.000000             try
    2              0.000649                 exe cmd
    2   0.000015   0.000009                 let Pat[3] = s:Reltime(start)
                                            " Hide ESC Terminal Chars
    2   0.000010   0.000004                 let start = s:Reltime()
    2   0.000100   0.000012                 call s:TermConceal(s:color_patterns_special.term_conceal[0])
    2   0.000016   0.000011                 let s:color_patterns_special.term_conceal[3] = s:Reltime(start)
    2              0.000002             catch
                                            " some error occured, stop when finished (and don't setup auto
                                            " comands
                                            let error=" ColorTerm "
                                            break
                                        endtry
    2              0.000001         endif
   30              0.000015     endfor
                            
                                " convert matches into synatx highlighting, so TOhtml can display it
                                " correctly
   15   0.000119   0.000075     call s:SyntaxMatcher(s:color_syntax)
   15              0.000057     if !exists("#FTColorizer#BufWinEnter#<buffer>") && empty(error)
                                    " Initialise current window.
    1   0.000084   0.000003         call Colorizer#LocalFTAutoCmds(1)
    1   0.000030   0.000004         call Colorizer#ColorWinEnter(1, 1) " don't call DoColor recursively!
    1              0.000001     endif
   15   0.000103   0.000055     let s:relstop = s:Reltime(s:relstart)
   15              0.000024     if !empty(error)
                                    " Some error occured, stop trying to color the file
                                    call Colorizer#ColorOff()
                                    call s:Warn("Some error occured here: ". error)
                                    if exists("s:position")
                                        call s:Warn("Position: ". string(s:position))
                                        call matchadd('Color_Error', '\%'.s:position[1].'l\%'.s:position[2].'c.*\>')
                                    endif
                                endif
   15   0.000278   0.000050     call s:PrintColorStatistics()
   15   0.001689   0.000059     call s:SaveRestoreOptions(0, save, [])
   15              0.000088     call winrestview(_a)

FUNCTION  <SNR>93_should_change_group()
Called 22 times
Total time:   0.004076
 Self time:   0.000362

count  total (s)   self (s)
   22              0.000035   if a:group1 == a:group2
                                return 0
                              endif
   22   0.001943   0.000075   let color1 = airline#highlighter#get_highlight(a:group1)
   22   0.001918   0.000072   let color2 = airline#highlighter#get_highlight(a:group2)
   22              0.000028   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   22              0.000059     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>79_update_hg_branch()
Called 34 times
Total time:   0.000927
 Self time:   0.000927

count  total (s)   self (s)
   34              0.000039   if s:has_lawrencium
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
   34              0.000070     let s:vcs_config['mercurial'].branch = ''
   34              0.000019   endif

FUNCTION  ale#util#InSandbox()
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000004     try
    3              0.000007         function! s:SandboxCheck() abort
                                    endfunction
    3              0.000005     catch /^Vim\%((\a\+)\)\=:E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
    3              0.000003     return 0

FUNCTION  <SNR>50_repo_head()
Called 34 times
Total time:   0.003078
 Self time:   0.000780

count  total (s)   self (s)
   34   0.002061   0.000175     let head = s:repo().head_ref()
                            
   34              0.000161     if head =~# '^ref: '
   34   0.000579   0.000167       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
   34              0.000034     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
   34              0.000033     return branch

FUNCTION  gitgutter#init_buffer()
Called 8 times
Total time:   0.000136
 Self time:   0.000083

count  total (s)   self (s)
    8   0.000079   0.000026   if gitgutter#utility#is_active(a:bufnr)
                                let p = gitgutter#utility#repo_path(a:bufnr, 0)
                                if type(p) != s:t_string || empty(p)
                                  call gitgutter#utility#set_repo_path(a:bufnr)
                                endif
                              endif

FUNCTION  airline#parts#crypt()
Called 34 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
   34              0.000127   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#keymap#status()
Called 34 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
   34              0.000154   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   34              0.000126     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>97_reset_tick()
Called 8 times
Total time:   0.000115
 Self time:   0.000033

count  total (s)   self (s)
    8   0.000109   0.000027   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  <SNR>102_UpdateMatches()
Called 16 times
Total time:   0.002919
 Self time:   0.002919

count  total (s)   self (s)
   16              0.002913   exec s:python_command "ycm_state.UpdateMatches()"

FUNCTION  <SNR>94_build_sections()
Called 9 times
Total time:   0.001884
 Self time:   0.000353

count  total (s)   self (s)
   46              0.000046   for key in a:keys
   37              0.000072     if (key == 'warning' || key == 'error') && !a:context.active
    6              0.000004       continue
                                endif
   31   0.001652   0.000121     call s:add_section(a:builder, a:context, key)
   31              0.000018   endfor

FUNCTION  <SNR>24_CreateDelimMapFromCms()
Called 4 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    4              0.000032     if &ft == '' && exists('g:NERDDefaultDelims')
                                    let delims = g:NERDDefaultDelims
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(delims, i)
                                            let delims[i] = ''
                                        endif
                                    endfor
                                    return delims
                                endif
    4              0.000097     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}

FUNCTION  <SNR>79_update_branch()
Called 34 times
Total time:   0.006747
 Self time:   0.001225

count  total (s)   self (s)
  102              0.000160   for vcs in keys(s:vcs_config)
   68   0.005888   0.000366     call {s:vcs_config[vcs].update_branch}()
   68              0.000185     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
   68              0.000045   endfor

FUNCTION  <SNR>102_OnBlankLine()
Called 14 times
Total time:   0.005482
 Self time:   0.000058

count  total (s)   self (s)
   14   0.005477   0.000053   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  gitgutter#diff#run_diff()
Called 2 times
Total time:   0.002838
 Self time:   0.000294

count  total (s)   self (s)
    2   0.000037   0.000011   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                sleep 5m
                              endwhile
                            
    2   0.000031   0.000005   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    2              0.000002   let cmd = '('
                            
                              " Append buffer number to avoid race conditions between writing and reading
                              " the files when asynchronously processing multiple buffers.
                              "
                              " Without the buffer number, index_file would have a race in the shell
                              " between the second process writing it (with git-show) and the first
                              " reading it (with git-diff).
    2              0.000006   let index_file = s:temp_index.'.'.a:bufnr
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    2              0.000006   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
    2   0.000049   0.000012   let extension = gitgutter#utility#extension(a:bufnr)
    2              0.000003   if !empty(extension)
    2              0.000005     let index_file .= '.'.extension
    2              0.000002     let buff_file .= '.'.extension
    2              0.000000   endif
                            
                              " Write file from index to temporary file.
    2   0.000070   0.000009   let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    2              0.000010   let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.index_file.' && '
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    2   0.000321   0.000025   call s:write_buffer(a:bufnr, buff_file)
                            
                              " Call git-diff with the temporary files.
    2              0.000005   let cmd .= g:gitgutter_git_executable.' --no-pager'
    2              0.000002   if s:c_flag
    2              0.000004     let cmd .= ' -c "diff.autorefreshindex=0"'
    2              0.000004     let cmd .= ' -c "diff.noprefix=false"'
    2              0.000002     let cmd .= ' -c "core.safecrlf=false"'
    2              0.000002   endif
    2              0.000008   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.index_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    2              0.000005   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    2   0.000065   0.000018     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    2              0.000000   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    2              0.000004   let cmd .= ' || exit 0'
                            
    2              0.000002   let cmd .= ')'
                            
    2   0.000152   0.000013   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    2   0.000017   0.000014   if g:gitgutter_async && gitgutter#async#available()
    2   0.001976   0.000067     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    2              0.000005     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  GitGutterGetHunkSummary()
Called 34 times
Total time:   0.000630
 Self time:   0.000141

count  total (s)   self (s)
   34   0.000626   0.000137   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  Colorizer#ColorLine()
Called 33 times
Total time:   0.090499
 Self time:   0.000346

count  total (s)   self (s)
   33              0.000144     if get(b:, 'Colorizer_changedtick', 0) == b:changedtick && empty(a:force)
                                    " nothing to do
   18              0.000015         return
                                else
   15   0.090244   0.000091         call Colorizer#DoColor(a:force, a:start, a:end)
   15              0.000031         let b:Colorizer_changedtick = b:changedtick
   15              0.000010     endif

FUNCTION  <SNR>14_CheckTimeout()
Called 105 times
Total time:   0.059951
 Self time:   0.059951

count  total (s)   self (s)
                                " Abort, if pattern is not found within 100 ms and force
                                " is not set
  105              0.059857     return (!empty(a:force) || search(a:pattern, 'cnw', '', 100))

FUNCTION  <SNR>56_SendHeartbeats()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002         let start_time = localtime()
    1              0.000001         let stdout = ''
                            
    1              0.000002         if len(s:heartbeats_buffer) == 0
    1              0.000001             let s:last_sent = start_time
    1              0.000000             return
                                    endif
                            
                                    let heartbeat = s:heartbeats_buffer[0]
                                    let s:heartbeats_buffer = s:heartbeats_buffer[1:-1]
                                    if len(s:heartbeats_buffer) > 0
                                        let extra_heartbeats = s:GetHeartbeatsJson()
                                    else
                                        let extra_heartbeats = ''
                                    endif
                            
                                    let python_bin = g:wakatime_PythonBinary
                                    if s:IsWindows()
                                        if python_bin == 'python'
                                            let python_bin = 'pythonw'
                                        endif
                                    endif
                                    let cmd = [python_bin, '-W', 'ignore', s:cli_location]
                                    let cmd = cmd + ['--entity', heartbeat.entity]
                                    let cmd = cmd + ['--time', heartbeat.time]
                                    let cmd = cmd + ['--plugin', printf('vim/%d vim-wakatime/%s', v:version, s:VERSION)]
                                    if heartbeat.is_write
                                        let cmd = cmd + ['--write']
                                    endif
                                    if has_key(heartbeat, 'language')
                                        let cmd = cmd + ['--language', heartbeat.language]
                                    endif
                                    if extra_heartbeats != ''
                                        let cmd = cmd + ['--extra-heartbeats']
                                    endif
                            
                                    " overwrite shell
                                    let [sh, shellcmdflag, shrd] = [&shell, &shellcmdflag, &shellredir]
                                    if !s:IsWindows()
                                        set shell=sh shellredir=>%s\ 2>&1
                                    endif
                            
                                    if s:has_async
                                        let job = job_start([&shell, &shellcmdflag, s:JoinArgs(cmd)], { 'stoponexit': '', 'callback': {channel, output -> s:AsyncHandler(output, cmd)}})
                                        if extra_heartbeats != ''
                                            let channel = job_getchannel(job)
                                            call ch_sendraw(channel, extra_heartbeats . "\n")
                                        endif
                                    elseif s:nvim_async
                                        let s:nvim_async_output = ['']
                                        let job = jobstart([&shell, &shellcmdflag, s:JoinArgs(cmd)], { 'detach': 1, 'on_stdout': function('s:NeovimAsyncOutputHandler'), 'on_stderr': function('s:NeovimAsyncOutputHandler'), 'on_exit': function('s:NeovimAsyncExitHandler')})
                                        if extra_heartbeats != ''
                                            call jobsend(job, extra_heartbeats . "\n")
                                        endif
                                    elseif s:IsWindows()
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')', extra_heartbeats)
                                            else
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')')
                                            endif
                                        else
                                            exec 'silent !start /b cmd /c "' . s:JoinArgs(cmd) . ' > nul 2> nul"'
                                        endif
                                    else
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd), extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd))
                                            endif
                                        else
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd) . ' &', extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd) . ' &')
                                            endif
                                        endif
                                    endif
                            
                                    " restore shell
                                    let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                            
                                    let s:last_sent = localtime()
                            
                                    " need to repaint in case a key was pressed while sending
                                    if !s:has_async && !s:nvim_async && s:redraw_setting != 'disabled'
                                        if s:redraw_setting == 'auto'
                                            if s:last_sent - start_time > 0
                                                redraw!
                                            endif
                                        else
                                            redraw!
                                        endif
                                    endif
                            
                                    if s:is_debug_on && stdout != ''
                                        echoerr '[WakaTime] Heartbeat Command: ' . s:JoinArgs(cmd) . "\n[WakaTime] Error: " . stdout
                                    endif

FUNCTION  <SNR>81_airline_ale_get_line_number()
Called 88 times
Total time:   0.007956
 Self time:   0.007527

count  total (s)   self (s)
   88              0.000097   if a:cnt == 0
   20              0.000012     return ''
                              endif
                            
   68              0.000117   let buffer       = bufnr('')
   68              0.000130   let problem_type = (a:type ==# 'error') ? 'E' : 'W'
   68   0.000988   0.000559   let problems     = copy(ale#engine#GetLoclist(buffer))
                            
   68              0.005576   call filter(problems, 'v:val.bufnr is buffer && v:val.type is# problem_type')
                            
   68              0.000099   if empty(problems)
                                return ''
                              endif
                            
   68              0.000192   let open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
   68              0.000182   let close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
   68              0.000212   return open_lnum_symbol . problems[0].lnum . close_lnum_symbol

FUNCTION  <SNR>94_get_section()
Called 45 times
Total time:   0.001084
 Self time:   0.000976

count  total (s)   self (s)
   45              0.000103   if has_key(s:section_truncate_width, a:key)
   27              0.000066     if winwidth(a:winnr) < s:section_truncate_width[a:key]
    7              0.000010       return ''
                                endif
   20              0.000007   endif
   38              0.000062   let spc = g:airline_symbols.space
   38              0.000118   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   38   0.000283   0.000175   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   38              0.000165   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   38              0.000095   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#extensions#quickfix#apply()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000003   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  <SNR>78_is_branch_empty()
Called 34 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
   34              0.000173   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 3 times
Total time:   0.000084
 Self time:   0.000025

count  total (s)   self (s)
    3   0.000039   0.000008   let summary = gitgutter#hunk#summary(a:bufnr)
    3              0.000006   let summary[2] += a:count
    3   0.000038   0.000010   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  gitgutter#async#execute()
Called 2 times
Total time:   0.001909
 Self time:   0.001846

count  total (s)   self (s)
    2   0.000068   0.000014   call gitgutter#debug#log('[async] '.a:cmd)
                            
    2              0.000008   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    2   0.000021   0.000012   let command = s:build_command(a:cmd)
                            
    2              0.000006   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
    2              0.001781     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    2              0.000002   endif

FUNCTION  gitgutter#diff#handler()
Called 2 times
Total time:   0.014845
 Self time:   0.000145

count  total (s)   self (s)
    2   0.000072   0.000011   call gitgutter#debug#log(a:diff)
                            
    2   0.000582   0.000025   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    2   0.001708   0.000023   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    2              0.000005   let signs_count = len(modified_lines)
    2              0.000002   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    2              0.000003     if g:gitgutter_signs || g:gitgutter_highlight_lines
    2   0.012382   0.000018       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    2              0.000001     endif
    2              0.000001   endif
                            
    2   0.000048   0.000015   call s:save_last_seen_change(a:bufnr)
    2              0.000017   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  airline#extensions#wordcount#apply()
Called 2 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000035   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  jedi#completions()
Called 2 times
Total time:   0.048588
 Self time:   0.048421

count  total (s)   self (s)
    2   0.048588   0.048421     PythonJedi jedi_vim.completions()

FUNCTION  <SNR>133_save_last_seen_change()
Called 2 times
Total time:   0.000033
 Self time:   0.000010

count  total (s)   self (s)
    2   0.000030   0.000007   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>14_SyntaxMatcher()
Called 15 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
   15              0.000022     if !a:enable
   15              0.000010         return
                                endif
                                let did_clean = {}
                                "
                                let list=s:GetMatchList()
                                if len(list) > 1000
                                    " This will probably slow
                                    call s:Warn("Colorizer many colors detected, syntax highlighting will probably slow down Vim considerably!")
                                endif
                                if &ft =~? 'css'
                                    " cssColor defines some color names like yellow or red and overrules
                                    " our colors
                                    sil! syn clear cssColor
                                endif
                                for hi in list
                                    if !get(did_clean, hi.group, 0)
                                        let did_clean[hi.group] = 1
                                        exe "sil! syn clear" hi.group
                                    endif
                                    if a:enable
                                        if has_key(hi, 'pattern')
                                            exe "syn match" hi.group "excludenl /". escape(hi.pattern, '/'). "/ display containedin=ALL"
                                        else
                                            " matchaddpos()
                                            let line=hi.pos1[0]
                                            let pos =hi.pos1[1]-1
                                            let len =hi.pos1[1]+hi.pos1[2]-2
                                            exe printf('syn match %s excludenl /\%%%dl\%%>%dc\&.*\%%<%dc/ display containedin=ALL', hi.group, line, pos, len)
                                        endif
                                        " We have syntax highlighting, can clear the matching
                                        " ignore errors (just in case)
                                        sil! call matchdelete(hi.id)
                                    endif
                                endfor

FUNCTION  airline#highlighter#add_separator()
Called 54 times
Total time:   0.009386
 Self time:   0.000462

count  total (s)   self (s)
   54              0.000221   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   54   0.009153   0.000229   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>56_GetLastHeartbeat()
Called 21 times
Total time:   0.000381
 Self time:   0.000381

count  total (s)   self (s)
   21              0.000105         if !s:last_heartbeat.last_activity_at || localtime() - s:last_heartbeat.last_activity_at > s:local_cache_expire
    1              0.000012             if !filereadable(s:data_file)
                                            return {'last_activity_at': 0, 'last_heartbeat_at': 0, 'file': ''}
                                        endif
    1              0.000012             let last = readfile(s:data_file, '', 3)
    1              0.000002             if len(last) == 3
    1              0.000003                 let s:last_heartbeat.last_heartbeat_at = last[1]
    1              0.000003                 let s:last_heartbeat.file = last[2]
    1              0.000000             endif
    1              0.000001         endif
   21              0.000023         return s:last_heartbeat

FUNCTION  fugitive#head()
Called 34 times
Total time:   0.004151
 Self time:   0.000371

count  total (s)   self (s)
   34              0.000068   if !exists('b:git_dir')
                                return ''
                              endif
                            
   34   0.004010   0.000230   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 4 times
Total time:   0.000131
 Self time:   0.000039

count  total (s)   self (s)
    4   0.000067   0.000016   let summary = gitgutter#hunk#summary(a:bufnr)
    4              0.000006   let summary[0] += a:count
    4   0.000054   0.000013   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  jedi#_vim_exceptions()
Called 20 times
Total time:   0.000367
 Self time:   0.000367

count  total (s)   self (s)
   20              0.000058     let l:result = {}
   20              0.000016     try
   20              0.000024         if a:is_eval
   20              0.000081             let l:result.result = eval(a:str)
   20              0.000008         else
                                        execute a:str
                                        let l:result.result = ''
                                    endif
   20              0.000018     catch
                                    let l:result.exception = v:exception
                                    let l:result.throwpoint = v:throwpoint
                                endtry
   20              0.000024     return l:result

FUNCTION  <SNR>102_IdentifierFinishedOperations()
Called 14 times
Total time:   0.004841
 Self time:   0.003215

count  total (s)   self (s)
   14   0.001672   0.000046   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
    6              0.000006     return
                              endif
    8              0.003073   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
    8              0.000037   let s:force_semantic = 0
    8              0.000022   let s:completion = s:default_completion

FUNCTION  <SNR>102_OnInsertChar()
Called 13 times
Total time:   0.000243
 Self time:   0.000153

count  total (s)   self (s)
   13              0.000084   call timer_stop( s:pollers.completion.id )
   13   0.000147   0.000057   call s:CloseCompletionMenu()

FUNCTION  <SNR>14_TermConceal()
Called 2 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
                                " Conceals a list of patterns
    2              0.000004     if exists("b:Colorizer_did_syntax")
    1              0.000001         return
                                endif
    1              0.000004     let s:position = getpos('.')
                                " concealing
   10              0.000010     for pat in a:pattern
    9              0.000044         exe "syn match ColorTermESC /". pat. "/ conceal containedin=ALL"
    9              0.000004     endfor
    1              0.000012     setl cocu=nv cole=2
    1              0.000002     let b:Colorizer_did_syntax=1

FUNCTION  ale#fix#ApplyQueuedFixes()
Called 8 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    8              0.000020     let l:buffer = bufnr('')
    8              0.000030     let l:data = get(g:ale_fix_buffer_data, l:buffer, {'done': 0})
                            
    8              0.000011     if !l:data.done
    8              0.000008         return
                                endif
                            
                                call remove(g:ale_fix_buffer_data, l:buffer)
                            
                                if l:data.changes_made
                                    call setline(1, l:data.output)
                            
                                    let l:start_line = len(l:data.output) + 1
                                    let l:end_line = len(l:data.lines_before)
                            
                                    if l:end_line >= l:start_line
                                        let l:save = winsaveview()
                                        silent execute l:start_line . ',' . l:end_line . 'd_'
                                        call winrestview(l:save)
                                    endif
                            
                                    if l:data.should_save
                                        if empty(&buftype)
                                            noautocmd :w!
                                        else
                                            set nomodified
                                        endif
                                    endif
                                endif
                            
                                if l:data.should_save
                                    let l:should_lint = g:ale_fix_on_save
                                else
                                    let l:should_lint = l:data.changes_made
                                endif
                            
                                " If ALE linting is enabled, check for problems with the file again after
                                " fixing problems.
                                if g:ale_enabled&& l:should_lint&& !ale#events#QuitRecently(l:buffer)
                                    call ale#Queue(0, l:data.should_save ? 'lint_file' : '')
                                endif

FUNCTION  <SNR>102_OnBufferEnter()
Called 8 times
Total time:   0.000137
 Self time:   0.000035

count  total (s)   self (s)
    8   0.000127   0.000025   if !s:VisitedBufferRequiresReparse()
    8              0.000004     return
                              endif
                            
                              call s:SetUpCompleteopt()
                              call s:SetCompleteFunc()
                              call s:StartMessagePoll()
                            
                              exec s:python_command "ycm_state.OnBufferVisit()"
                              " Last parse may be outdated because of changes from other buffers. Force a
                              " new parse.
                              call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>52_winshell()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000011   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  gitgutter#utility#is_active()
Called 18 times
Total time:   0.000400
 Self time:   0.000149

count  total (s)   self (s)
   18   0.000391   0.000140   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr) && !s:vimdiff(a:bufnr)

FUNCTION  airline#extensions#apply()
Called 7 times
Total time:   0.000516
 Self time:   0.000270

count  total (s)   self (s)
    7              0.000014   let s:active_winnr = winnr()
                            
    7   0.000269   0.000023   if s:is_excluded_window()
                                return -1
                              endif
                            
    7              0.000010   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    7              0.000007   if &previewwindow
    4              0.000008     let w:airline_section_a = 'Preview'
    4              0.000005     let w:airline_section_b = ''
    4              0.000012     let w:airline_section_c = bufname(winbufnr(winnr()))
    4              0.000003   endif
                            
    7              0.000046   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    7              0.000018   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  ale#engine#GetLoclist()
Called 68 times
Total time:   0.000429
 Self time:   0.000429

count  total (s)   self (s)
   68              0.000162     if !has_key(g:ale_buffer_info, a:buffer)
                                    return []
                                endif
                            
   68              0.000133     return g:ale_buffer_info[a:buffer].loclist

FUNCTION  <SNR>79_update_git_branch()
Called 34 times
Total time:   0.004595
 Self time:   0.000444

count  total (s)   self (s)
   34              0.000038   if !s:has_fugitive
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
   34   0.004302   0.000151   let s:vcs_config['git'].branch = fugitive#head(s:sha1size)
   34              0.000088   if s:vcs_config['git'].branch is# 'master' && winwidth(0) < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  pymode#folding#expr()
Called 3499 times
Total time:   1.976719
 Self time:   0.022387

count  total (s)   self (s)
                            
 3499   1.969530   0.015198     let l:return_value = pymode#folding#foldcase(a:lnum)['foldlevel']
                            
 3499              0.004128     return l:return_value
                            

FUNCTION  ale#cursor#EchoCursorWarning()
Called 2 times
Total time:   0.000826
 Self time:   0.000027

count  total (s)   self (s)
    2   0.000823   0.000024     return ale#CallWithCooldown('dont_echo_until', function('s:EchoImpl'), [])

FUNCTION  <SNR>52_is_file_buffer()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000016   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>102_CloseCompletionMenu()
Called 29 times
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
   29              0.000055   if pumvisible()
                                call s:SendKeys( "\<C-e>" )
                              endif

FUNCTION  gitgutter#diff#parse_diff()
Called 2 times
Total time:   0.000445
 Self time:   0.000147

count  total (s)   self (s)
    2              0.000004   let hunks = []
   12              0.000032   for line in split(a:diff, '\n')
   10   0.000348   0.000050     let hunk_info = gitgutter#diff#parse_hunk(line)
   10              0.000017     if len(hunk_info) == 4
   10              0.000019       call add(hunks, hunk_info)
   10              0.000004     endif
   10              0.000006   endfor
    2              0.000002   return hunks

FUNCTION  AutoPairsInsert()
Called 4 times
Total time:   0.000593
 Self time:   0.000593

count  total (s)   self (s)
    4              0.000034   if !b:autopairs_enabled
                                return a:key
                              end
                            
    4              0.000033   let line = getline('.')
    4              0.000029   let pos = col('.') - 1
    4              0.000019   let before = strpart(line, 0, pos)
    4              0.000010   let after = strpart(line, pos)
    4              0.000041   let next_chars = split(after, '\zs')
    4              0.000011   let current_char = get(next_chars, 0, '')
    4              0.000008   let next_char = get(next_chars, 1, '')
    4              0.000094   let prev_chars = split(before, '\zs')
    4              0.000010   let prev_char = get(prev_chars, -1, '')
                            
    4              0.000004   let eol = 0
    4              0.000016   if col('$') -  col('.') <= 1
    4              0.000005     let eol = 1
    4              0.000003   end
                            
                              " Ignore auto close if prev character is \
    4              0.000004   if prev_char == '\'
                                return a:key
                              end
                            
                              " The key is difference open-pair, then it means only for ) ] } by default
    4              0.000013   if !has_key(b:AutoPairs, a:key)
    2              0.000013     let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                                " Skip the character if current character is the same as input
    2              0.000008     if current_char == a:key
    2              0.000003       return s:Right
                                end
                            
                                if !g:AutoPairsFlyMode
                                  " Skip the character if next character is space
                                  if current_char == ' ' && next_char == a:key
                                    return s:Right.s:Right
                                  end
                            
                                  " Skip the character if closed pair is next character
                                  if current_char == ''
                                    if g:AutoPairsMultilineClose
                                      let next_lineno = line('.')+1
                                      let next_line = getline(nextnonblank(next_lineno))
                                      let next_char = matchstr(next_line, '\s*\zs.')
                                    else
                                      let next_char = matchstr(line, '\s*\zs.')
                                    end
                                    if next_char == a:key
                                      return "\<ESC>e^a"
                                    endif
                                  endif
                                endif
                            
                                " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                                if g:AutoPairsFlyMode && has_key(b:AutoPairsClosedPairs, a:key)
                                  let n = stridx(after, a:key)
                                  if n != -1
                                    return repeat(s:Right, n+1)
                                  end
                                  if search(a:key, 'W')
                                    " force break the '.' when jump to different line
                                    return "\<Right>"
                                  endif
                                endif
                            
                                " Insert directly if the key is not an open key
                                return a:key
                              end
                            
    2              0.000003   let open = a:key
    2              0.000006   let close = b:AutoPairs[open]
                            
    2              0.000004   if current_char == close && open == close
                                return s:Right
                              end
                            
                              " Ignore auto close ' if follows a word
                              " MUST after closed check. 'hello|'
    2              0.000003   if a:key == "'" && prev_char =~ '\v\w'
                                return a:key
                              end
                            
                              " support for ''' ``` and """
    2              0.000002   if open == close
                                " The key must be ' " `
                                let pprev_char = line[col('.')-3]
                                if pprev_char == open && prev_char == open
                                  " Double pair found
                                  return repeat(a:key, 4) . repeat(s:Left, 3)
                                end
                              end
                            
    2              0.000002   let quotes_num = 0
                              " Ignore comment line for vim file
    2              0.000007   if &filetype == 'vim' && a:key == '"'
                                if before =~ '^\s*$'
                                  return a:key
                                end
                                if before =~ '^\s*"'
                                  let quotes_num = -1
                                end
                              end
                            
                              " Keep quote number is odd.
                              " Because quotes should be matched in the same line in most of situation
    2              0.000005   if g:AutoPairsSmartQuotes && open == close
                                " Remove \\ \" \'
                                let cleaned_line = substitute(line, '\v(\\.)', '', 'g')
                                let n = quotes_num
                                let pos = 0
                                while 1
                                  let pos = stridx(cleaned_line, open, pos)
                                  if pos == -1
                                    break
                                  end
                                  let n = n + 1
                                  let pos = pos + 1
                                endwhile
                                if n % 2 == 1
                                  return a:key
                                endif
                              endif
                            
    2              0.000006   return open.close.s:Left

FUNCTION  <SNR>102_AllowedToCompleteInCurrentBuffer()
Called 20 times
Total time:   0.000711
 Self time:   0.000085

count  total (s)   self (s)
   20   0.000705   0.000079   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  pymode#folding#foldcase()
Called 3499 times
Total time:   1.954332
 Self time:   0.462649

count  total (s)   self (s)
                                " Return a dictionary with a brief description of the foldcase and the
                                " evaluated foldlevel: {'foldcase': 'case description', 'foldlevel': 1}.
                            
 3499              0.004547     let l:foldcase = 'general'
 3499              0.004037     let l:foldlevel = 0
                            
 3499              0.006698     let line = getline(a:lnum)
 3499              0.005778     let indent = indent(a:lnum)
 3499              0.007944     let prev_line = getline(a:lnum - 1)
 3499              0.007144     let next_line = getline(a:lnum + 1)
                            
                                " Decorators {{{
 3499              0.020956     if line =~ s:decorator_regex
                                    let l:foldcase = 'decorator declaration'
                                    let l:foldlevel = '>'.(indent / &shiftwidth + 1)
                                    return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                endif "}}}
                            
                                " Definition {{{
 3499              0.028275     if line =~ s:def_regex
                            
                                    " TODO: obscure case.
                                    " If indent of this line is greater or equal than line below
                                    " and previous non blank line does not end with : (that is, is not a
                                    " definition)
                                    " Keep the same indentation
                                    " xxx " if indent(a:lnum) >= indent(a:lnum+1)
                                    " xxx "         \ && getline(prevnonblank(a:lnum)) !~ ':\s*$'
                                    " xxx "     let l:foldcase = 'definition'
                                    " xxx "     let l:foldlevel = '='
                                    " xxx "     return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                    " xxx " endif
                            
                                    " Check if last decorator is before the last def
   32              0.000041         let decorated = 0
   32              0.000052         let lnum = a:lnum - 1
  448              0.000382         while lnum > 0
  448              0.003291             if getline(lnum) =~ s:def_regex
   32              0.000024                 break
                                        elseif getline(lnum) =~ s:decorator_regex
                                            let decorated = 1
                                            break
                                        endif
  416              0.000394             let lnum -= 1
  416              0.000304         endwhile
   32              0.000032         if decorated
                                        let l:foldcase = 'decorated function declaration'
                                        let l:foldlevel = '='
                                    else
   32              0.000047             let l:foldcase = 'function declaration'
   32              0.000097             let l:foldlevel = '>'.(indent / &shiftwidth + 1)
   32              0.000016         endif
   32              0.000084         return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                endif "}}}
                            
                                " Docstrings {{{
                            
                                " TODO: A while loop now counts the number of open and closed folding in
                                " order to determine if it is a closing or opening folding.
                                " It is working but looks like it is an overkill.
                            
                                " Notice that an effect of this is that other docstring matches will not
                                " be one liners.
 3467              0.028785     if line =~ s:docstring_line_regex
                                    let l:foldcase = 'one-liner docstring'
                                    let l:foldlevel = '='
                                    return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                endif
 3467              0.024648     if line =~ s:docstring_begin_regex
                                    if s:Is_opening_folding(a:lnum)
                                        let l:foldcase = 'open multiline docstring'
                                        let l:foldlevel = 'a1'
                                    endif
                                    return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                endif
 3467              0.031193     if line =~ s:docstring_end_regex
                                    if !s:Is_opening_folding(a:lnum)
                                        let l:foldcase = 'close multiline docstring'
                                        let l:foldlevel = 's1'
                                    endif
                                    return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                endif "}}}
                            
                                " Blocks. {{{
 3467              0.008095     let s:save_cursor = getcurpos()
 3467   0.693951   0.014379     let line_block_start = s:BlockStart(a:lnum)
 3467   0.156977   0.012453     let line_block_end = s:BlockEnd(a:lnum)
 3467   0.681828   0.014241     let prev_line_block_start = s:BlockStart(a:lnum - 1)
 3467              0.016431     if line !~ s:blank_regex
 2934              0.005798         if line_block_start == prev_line_block_start || a:lnum  - line_block_start == 1
 2934              0.005044             let l:foldcase = 'non blank line; first line of block or part of it'
 2934              0.003230             let l:foldlevel = '='
 2934              0.005337         elseif indent < indent(prevnonblank(a:lnum - 1))
                                        if indent == 0
                                            let l:foldcase = 'non blank line; zero indent'
                                            let l:foldlevel = 0
                                        else
                                            let l:foldcase = 'non blank line; non zero indent'
                                            let l:foldlevel = indent(line_block_start) / &shiftwidth + 1
                                        endif
                                    endif
 2934              0.006206         call setpos('.', s:save_cursor)
 2934              0.007596         return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                else
  533              0.001089         call setpos('.', s:save_cursor)
  533              0.000288     endif
                                " endif " }}}
                            
                                " Blank Line {{{
                                " Comments: cases of blank lines:
                                " 1. After non blank line: gets folded with previous line.
                                " 1. Just after a block; in this case it gets folded with the block.
                                " 1. Between docstrings and imports.
                                " 1. Inside docstrings.
                                " 2. Inside functions/methods.
                                " 3. Between functions/methods.
  533              0.001344     if line =~ s:blank_regex
  533              0.002592         if prev_line !~ s:blank_regex
  533              0.000866             let l:foldcase = 'blank line after non blank line'
  533              0.000573             let l:foldlevel = '='
  533              0.001328             return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                    elseif a:lnum > line_block_start && a:lnum < line_block_end
                                        let l:foldcase = 'blank line inside block'
                                        let l:foldlevel = '='
                                        return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                    endif
                                    " if prev_line =~ s:blank_regex
                                    "     if indent(a:lnum + 1) == 0 && next_line !~ s:blank_regex && next_line !~ s:docstring_general_regex
                                    "         if s:Is_opening_folding(a:lnum)
                                    "             let l:foldcase = 'case 1'
                                    "             let l:foldlevel = '='
                                    "             return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                    "         else
                                    "             let l:foldcase = 'case 2'
                                    "             let l:foldlevel = 0
                                    "             return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                    "         endif
                                    "     endif
                                    "     let l:foldcase = 'case 3'
                                    "     let l:foldlevel = -1
                                    "     return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                    " else
                                    "     let l:foldcase = 'case 4'
                                    "     let l:foldlevel = '='
                                    "     return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                                    " endif
                                endif " }}}
                            
                                return {'foldcase': l:foldcase, 'foldlevel': l:foldlevel}
                            

FUNCTION  <SNR>106_EchoImpl()
Called 2 times
Total time:   0.000719
 Self time:   0.000076

count  total (s)   self (s)
    2              0.000003     if !g:ale_echo_cursor
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    2              0.000003     if mode() isnot# 'n'
                                    return
                                endif
                            
    2   0.000228   0.000009     if ale#ShouldDoNothing(bufnr(''))
                                    return
                                endif
                            
    2              0.000004     let l:buffer = bufnr('')
    2   0.000441   0.000017     let [l:info, l:loc] = s:FindItemAtCursor()
                            
    2              0.000004     if !empty(l:loc)
                                    let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                    let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                    call ale#cursor#TruncatedEcho(l:msg)
                                    let l:info.echoed = 1
                                elseif get(l:info, 'echoed')
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
                                    execute 'echo'
                                    let l:info.echoed = 0
                                endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 4 times
Total time:   0.001034
 Self time:   0.000105

count  total (s)   self (s)
    4              0.000011   if getbufvar(a:bufnr, '&modified')
    3              0.000028     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    3              0.000002   else
    1              0.000008     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    1              0.000001   endif
                            
    4              0.000005   if !empty(colors)
    4   0.000956   0.000027     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    4              0.000002   endif

FUNCTION  <SNR>102_OnFileReadyToParse()
Called 1 time
Total time:   0.000709
 Self time:   0.000594

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    1              0.000002   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    1   0.000118   0.000003   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    1              0.000571     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    1              0.000005     call timer_stop( s:pollers.file_parse_response.id )
    1              0.000009     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    1              0.000001   endif

FUNCTION  airline#extensions#branch#get_head()
Called 34 times
Total time:   0.009998
 Self time:   0.000520

count  total (s)   self (s)
   34   0.009590   0.000112   let head = airline#extensions#branch#head()
   34              0.000109   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
   34              0.000100   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   34              0.000174   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  <SNR>106_StopCursorTimer()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002     if s:cursor_timer != -1
    1              0.000002         call timer_stop(s:cursor_timer)
    1              0.000002         let s:cursor_timer = -1
    1              0.000001     endif

FUNCTION  <SNR>102_OnCompleteDone()
Called 1 time
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    1              0.000105   exec s:python_command "ycm_state.OnCompleteDone()"

FUNCTION  airline#extensions#hunks#get_hunks()
Called 34 times
Total time:   0.004042
 Self time:   0.002196

count  total (s)   self (s)
   34              0.000069   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
   34              0.000354   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
   34   0.001952   0.000106   let hunks = s:get_hunks()
   34              0.000035   let string = ''
   34              0.000048   if !empty(hunks)
  136              0.000137     for i in [0, 1, 2]
  102              0.000296       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
  102              0.000423         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  102              0.000056       endif
  102              0.000061     endfor
   34              0.000017   endif
   34              0.000050   let b:airline_hunks = string
   34              0.000064   let b:airline_changenr = b:changedtick
   34              0.000062   let s:airline_winwidth = winwidth(0)
   34              0.000035   return string

FUNCTION  <SNR>14_GetMatchList()
Called 16 times
Total time:   0.004994
 Self time:   0.004994

count  total (s)   self (s)
                                " this is window-local!
   16              0.004977     return filter(getmatches(), 'v:val.group =~ ''^\(Color_\w\+\)\|NONE''')

FUNCTION  AutoPairsTryInit()
Called 8 times
Total time:   0.000551
 Self time:   0.000102

count  total (s)   self (s)
    8              0.000020   if exists('b:autopairs_loaded')
    7              0.000004     return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    1              0.000001   if g:AutoPairsMapCR
    1              0.000003     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    1              0.000013       let info = maparg('<CR>', 'i', 0, 1)
    1              0.000001       if empty(info)
    1              0.000001         let old_cr = '<CR>'
    1              0.000001         let is_expr = 0
    1              0.000000       else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
    1              0.000001     else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
    1              0.000003     if old_cr !~ 'AutoPairsReturn'
    1              0.000001       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
    1              0.000012       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    1              0.000001     end
    1              0.000000   endif
    1   0.000457   0.000008   call AutoPairsInit()

FUNCTION  <SNR>50_sub()
Called 34 times
Total time:   0.000412
 Self time:   0.000412

count  total (s)   self (s)
   34              0.000397   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  jedi#complete_opened()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000002     if a:autocomplete
    1              0.000005         let &completeopt = s:saved_completeopt
    1              0.000002         unlet s:saved_completeopt
    1              0.000002     elseif pumvisible() && g:jedi#popup_select_first && stridx(&completeopt, 'longest') > -1
                                    return "\<Down>"
                                endif
    1              0.000001     return ''

FUNCTION  jedi#do_popup_on_dot_in_highlight()
Called 1 time
Total time:   0.000209
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000171   0.000008     let highlight_groups = s:syn_stack()
    2              0.000004     for a in highlight_groups
    1              0.000001         if a ==# 'pythonDoctest'
                                        return 1
                                    endif
    1              0.000002     endfor
                            
    2              0.000003     for a in highlight_groups
    4              0.000004         for b in ['pythonString', 'pythonComment', 'pythonNumber']
    3              0.000003             if a == b
                                            return 0
                                        endif
    3              0.000002         endfor
    1              0.000000     endfor
    1              0.000001     return 1

FUNCTION  <SNR>61_Highlight_Matching_Pair()
Called 39 times
Total time:   0.017700
 Self time:   0.017700

count  total (s)   self (s)
                              " Remove any previous match.
   39              0.000129   if exists('w:paren_hl_on') && w:paren_hl_on
    8              0.000040     silent! call matchdelete(3)
    8              0.000010     let w:paren_hl_on = 0
    8              0.000006   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   39              0.000121   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
    8              0.000003     return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   31              0.000060   let c_lnum = line('.')
   31              0.000055   let c_col = col('.')
   31              0.000031   let before = 0
                            
   31              0.000065   let text = getline(c_lnum)
   31              0.000401   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   31              0.000053   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
   31              0.000099     let [c_before, c] = matches[1:2]
   31              0.000020   endif
   31              0.000295   let plist = split(&matchpairs, '.\zs[:,]')
   31              0.000068   let i = index(plist, c)
   31              0.000029   if i < 0
                                " not found, in Insert mode try character before the cursor
   24              0.000070     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   24              0.000051       let before = strlen(c_before)
   24              0.000029       let c = c_before
   24              0.000043       let i = index(plist, c)
   24              0.000010     endif
   24              0.000020     if i < 0
                                  " not found, nothing to do
   22              0.000017       return
                                endif
    2              0.000002   endif
                            
                              " Figure out the arguments for searchpairpos().
    9              0.000009   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
    9              0.000010     let s_flags = 'nbW'
    9              0.000011     let c2 = c
    9              0.000017     let c = plist[i - 1]
    9              0.000006   endif
    9              0.000009   if c == '['
    9              0.000009     let c = '\['
    9              0.000009     let c2 = '\]'
    9              0.000005   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    9              0.000007   if before > 0
    2              0.000006     let has_getcurpos = exists("*getcurpos")
    2              0.000002     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    2              0.000004       let save_cursor = getcurpos()
    2              0.000002     else
                                  let save_cursor = winsaveview()
                                endif
    2              0.000006     call cursor(c_lnum, c_col - before)
    2              0.000001   endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    9              0.000028   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
    9              0.012893   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    9              0.000027   let stoplinebottom = line('w$')
    9              0.000020   let stoplinetop = line('w0')
    9              0.000009   if i % 2 == 0
                                let stopline = stoplinebottom
                              else
    9              0.000011     let stopline = stoplinetop
    9              0.000005   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    9              0.000020   if mode() == 'i' || mode() == 'R'
    8              0.000033     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    8              0.000005   else
    1              0.000003     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    1              0.000001   endif
    9              0.000007   try
    9              0.001611     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    9              0.000012   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    9              0.000010   if before > 0
    2              0.000002     if has_getcurpos
    2              0.000007       call setpos('.', save_cursor)
    2              0.000000     else
                                  call winrestview(save_cursor)
                                endif
    2              0.000002   endif
                            
                              " If a match is found setup match highlighting.
    9              0.000022   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    9              0.000019     if exists('*matchaddpos')
    9              0.000132       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
    9              0.000004     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
    9              0.000014     let w:paren_hl_on = 1
    9              0.000003   endif

FUNCTION  <SNR>14_IsInComment()
Called 7 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    7              0.000024     return s:skip_comments && synIDattr(synIDtrans(synID(line('.'), col('.'),1)), 'name') == "Comment"

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 1 time
Total time:   0.000059
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000002     if !g:ale_echo_cursor
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    1              0.000002     if mode() isnot# 'n'
                                    return
                                endif
                            
    1   0.000015   0.000008     call s:StopCursorTimer()
                            
    1              0.000003     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    1              0.000002     if l:pos != s:last_pos
    1   0.000022   0.000004         let l:delay = ale#Var(bufnr(''), 'echo_delay')
                            
    1              0.000003         let s:last_pos = l:pos
    1              0.000004         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    1              0.000000     endif

FUNCTION  <SNR>89_get_array()
Called 669 times
Total time:   0.004188
 Self time:   0.004188

count  total (s)   self (s)
  669              0.001701   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  669              0.002255   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  airline#extensions#ale#get_warning()
Called 44 times
Total time:   0.007108
 Self time:   0.000185

count  total (s)   self (s)
   44   0.007084   0.000161   return airline#extensions#ale#get('warning')

FUNCTION  gitgutter#hunk#set_hunks()
Called 2 times
Total time:   0.000112
 Self time:   0.000031

count  total (s)   self (s)
    2   0.000056   0.000017   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    2   0.000055   0.000013   call s:reset_summary(a:bufnr)

FUNCTION  airline#builder#new()
Called 7 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    7              0.000030   let builder = copy(s:prototype)
    7              0.000014   let builder._context = a:context
    7              0.000009   let builder._sections = []
                            
    7              0.000047   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    7              0.000007   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
 3499   1.976719   0.022387  pymode#folding#expr()
 3499   1.954332   0.462649  pymode#folding#foldcase()
 6934   1.347159             <SNR>135_BlockStart()
 3467   0.144524             <SNR>135_BlockEnd()
  107   0.105219   0.006517  airline#check_mode()
    4   0.097668   0.010754  airline#highlighter#highlight()
   33   0.090499   0.000346  Colorizer#ColorLine()
   15   0.090153   0.009824  Colorizer#DoColor()
  427   0.076268   0.021599  airline#highlighter#exec()
  105   0.059951             <SNR>14_CheckTimeout()
  669   0.057381   0.024417  airline#highlighter#get_highlight()
    2   0.048588   0.048421  jedi#completions()
   10   0.046062   0.000362  gitgutter#process_buffer()
    8   0.042483   0.000136  <SNR>97_clear()
    8   0.041848   0.000164  gitgutter#sign#clear_signs()
  129   0.037278   0.002768  <SNR>89_exec_separator()
   10   0.035101   0.035011  <SNR>98_remove_signs()
    2   0.030695   0.030532  jedi#show_call_signatures()
 1338   0.028776             <SNR>89_get_syn()
   14   0.023927   0.004374  <SNR>102_OnTextChangedInsertMode()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 6934              1.347159  <SNR>135_BlockStart()
 3499   1.954332   0.462649  pymode#folding#foldcase()
 3467              0.144524  <SNR>135_BlockEnd()
  105              0.059951  <SNR>14_CheckTimeout()
    2   0.048588   0.048421  jedi#completions()
   10   0.035101   0.035011  <SNR>98_remove_signs()
    2   0.030695   0.030532  jedi#show_call_signatures()
 1338              0.028776  <SNR>89_get_syn()
  669   0.057381   0.024417  airline#highlighter#get_highlight()
 3499   1.976719   0.022387  pymode#folding#expr()
  427   0.076268   0.021599  airline#highlighter#exec()
   39              0.017700  <SNR>61_Highlight_Matching_Pair()
   54              0.012290  <SNR>102_Pyeval()
    4   0.097668   0.010754  airline#highlighter#highlight()
  427              0.010609  <SNR>89_CheckDefined()
   15   0.090153   0.009824  Colorizer#DoColor()
   10   0.009991   0.009607  <SNR>98_find_current_signs()
    8   0.011133   0.008072  ale#highlight#UpdateHighlights()
    2   0.008291   0.007790  <SNR>98_upsert_new_gitgutter_signs()
   88   0.007956   0.007527  <SNR>81_airline_ale_get_line_number()

